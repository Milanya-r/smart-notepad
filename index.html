<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Умный Блокнот</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#0891b2">
    <!-- Version 1.0 - All-in-one build -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        darkMode: 'class',
      }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify/dist/purify.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script>
      // Prevents Flash of Incorrect Theme (FOIT)
      (function() {
        try {
          var theme = localStorage.getItem('theme');
          if (theme) {
            if (JSON.parse(theme) === 'dark') {
              document.documentElement.classList.add('dark');
            }
          } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
          }
        } catch (_) {}
      })();
    </script>
    <style>
      body {
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }
      /* Light theme markdown */
      .markdown-content h1, .markdown-content h2, .markdown-content h3 { color: #1e293b; font-weight: 600; margin-bottom: 0.5em; margin-top: 1em; }
      .markdown-content h1 { font-size: 1.5em; }
      .markdown-content h2 { font-size: 1.25em; }
      .markdown-content h3 { font-size: 1.1em; }
      .markdown-content p { margin-bottom: 0.75em; }
      .markdown-content ul, .markdown-content ol { margin-left: 1.5em; margin-bottom: 1em; }
      .markdown-content ul { list-style-type: disc; }
      .markdown-content ol { list-style-type: decimal; }
      .markdown-content li { margin-bottom: 0.25em; }
      .markdown-content a { color: #0891b2; text-decoration: underline; }
      .markdown-content blockquote { border-left: 4px solid #cbd5e1; padding-left: 1em; margin-left: 0; font-style: italic; color: #475569; }
      .markdown-content code { background-color: #f1f5f9; padding: 0.2em 0.4em; border-radius: 4px; font-family: monospace; }
      .markdown-content pre { background-color: #f1f5f9; padding: 1em; border-radius: 6px; overflow-x: auto; }
      .markdown-content pre code { padding: 0; background-color: transparent; }
      .markdown-content li.task-list-item { list-style-type: none !important; margin-left: -1.5em; }
      .markdown-content li.task-list-item { display: flex; align-items: center; }
      .markdown-content li.task-list-item input[type="checkbox"] { margin-right: 0.75em; appearance: none; width: 1.15em; height: 1.15em; border: 2px solid #94a3b8; border-radius: 4px; cursor: pointer; position: relative; top: -1px; flex-shrink: 0; }
      .markdown-content li.task-list-item input[type="checkbox"]:checked { background-color: #0891b2; border-color: #0891b2; }
      .markdown-content li.task-list-item input[type="checkbox"]:checked::before { content: '✔'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 0.8em; color: #ffffff; }
      .markdown-content li.task-list-item.done { color: #64748b; text-decoration: line-through; }
      
      /* Dark theme markdown */
      .dark .markdown-content h1, .dark .markdown-content h2, .dark .markdown-content h3 { color: #e2e8f0; }
      .dark .markdown-content a { color: #22d3ee; }
      .dark .markdown-content blockquote { border-left-color: #475569; color: #94a3b8; }
      .dark .markdown-content code { background-color: #1e293b; }
      .dark .markdown-content pre { background-color: #1e293b; }
      .dark .markdown-content li.task-list-item input[type="checkbox"] { border-color: #475569; }
      .dark .markdown-content li.task-list-item input[type="checkbox"]:checked { background-color: #22d3ee; border-color: #22d3ee; }
      .dark .markdown-content li.task-list-item input[type="checkbox"]:checked::before { color: #0f172a; }
      .dark .markdown-content li.task-list-item.done { color: #64748b; }
    </style>
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-messaging.js"></script>

  </head>
  <body>
    <div id="root"></div>
    <script type="text/babel" data-presets="react">
      const { useState, useEffect, useMemo, useRef, useCallback } = React;
      
      // --- Start of Bundled Code ---

      // hooks/useLocalStorage.js
      function useLocalStorage(key, initialValue) {
        const [storedValue, setStoredValue] = useState(() => {
          try {
            if (typeof window === 'undefined') {
              return initialValue;
            }
            const item = window.localStorage.getItem(key);
            return item ? JSON.parse(item) : initialValue;
          } catch (error) {
            console.error(error);
            return initialValue;
          }
        });

        useEffect(() => {
          try {
            if (typeof window !== 'undefined') {
              window.localStorage.setItem(key, JSON.stringify(storedValue));
            }
          } catch (error) {
            console.error('Error saving to localStorage', error);
          }
        }, [key, storedValue]);

        useEffect(() => {
          if (typeof window === 'undefined') return;
          
          const handleStorageChange = (e) => {
            if (e.key === key) {
              try {
                if (e.newValue === null) {
                  setStoredValue(initialValue);
                } else {
                  setStoredValue(JSON.parse(e.newValue));
                }
              } catch (error) {
                console.error('Error parsing stored value on storage event', error);
                setStoredValue(initialValue);
              }
            }
          };

          window.addEventListener('storage', handleStorageChange);
          return () => {
            window.removeEventListener('storage', handleStorageChange);
          };
        }, [key, initialValue]);

        return [storedValue, setStoredValue];
      }

      // components/icons.js
      const PlusIcon = ({ className = 'w-6 h-6' }) => (
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
          <path strokeLinecap="round" strokeLinejoin="round" d="M12 4.5v15m7.5-7.5h-15" />
        </svg>
      );
      const StarIcon = ({ className = 'w-6 h-6', filled = false }) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill={filled ? "currentColor" : "none"} stroke="currentColor" strokeWidth={1.5} className={className}>
          <path strokeLinecap="round" strokeLinejoin="round" d="M11.48 3.499a.562.562 0 011.04 0l2.125 5.111a.563.563 0 00.475.345l5.518.442c.499.04.701.663.321.988l-4.204 3.602a.563.563 0 00-.182.557l1.285 5.385a.562.562 0 01-.84.61l-4.725-2.885a.563.563 0 00-.586 0L6.982 20.54a.562.562 0 01-.84-.61l1.285-5.386a.562.562 0 00-.182-.557l-4.204-3.602a.563.563 0 01.321-.988l5.518-.442a.563.563 0 00.475-.345L11.48 3.5z" />
        </svg>
      );
      const TrashIcon = ({ className = 'w-6 h-6' }) => (
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
          <path strokeLinecap="round" strokeLinejoin="round" d="M14.74 9l-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 01-2.244 2.077H8.084a2.25 2.25 0 01-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 00-3.478-.397m-12.548 0A48.094 48.094 0 016.25 5.397m11.5 0a48.11 48.11 0 00-7.5 0" />
        </svg>
      );
      const PencilIcon = ({ className = 'w-6 h-6' }) => (
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
          <path strokeLinecap="round" strokeLinejoin="round" d="M16.862 4.487l1.687-1.688a1.875 1.875 0 112.652 2.652L6.832 19.82a4.5 4.5 0 01-1.897 1.13l-2.685.8.8-2.685a4.5 4.5 0 011.13-1.897L16.863 4.487zm0 0L19.5 7.125" />
        </svg>
      );
      const XMarkIcon = ({ className = 'w-6 h-6' }) => (
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
          <path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" />
        </svg>
      );
      const FolderPlusIcon = ({ className = 'w-6 h-6' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M12 10.5v6m3-3H9m4.06-7.19-2.12-2.12a1.5 1.5 0 0 0-1.061-.44H4.5A2.25 2.25 0 0 0 2.25 6v12a2.25 2.25 0 0 0 2.25 2.25h15A2.25 2.25 0 0 0 21.75 18V9a2.25 2.25 0 0 0-2.25-2.25h-5.379a1.5 1.5 0 0 1-1.06-.44Z" />
          </svg>
      );
      const ArrowLeftIcon = ({ className = 'w-6 h-6' }) => (
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
          <path strokeLinecap="round" strokeLinejoin="round" d="M10.5 19.5L3 12m0 0l7.5-7.5M3 12h18" />
        </svg>
      );
      const CheckIcon = ({ className = 'w-6 h-6' }) => (
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
          <path strokeLinecap="round" strokeLinejoin="round" d="M4.5 12.75l6 6 9-13.5" />
        </svg>
      );
      const SearchIcon = ({ className = 'w-6 h-6' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="m21 21-5.197-5.197m0 0A7.5 7.5 0 1 0 5.196 5.196a7.5 7.5 0 0 0 10.607 10.607Z" />
          </svg>
      );
      const BellIcon = ({ className = 'w-6 h-6', filled = false }) => (
        <svg xmlns="http://www.w3.org/2000/svg" fill={filled ? "currentColor" : "none"} viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
          <path strokeLinecap="round" strokeLinejoin="round" d="M14.857 17.082a23.848 23.848 0 0 0 5.454-1.31A8.967 8.967 0 0 1 18 9.75V9A6 6 0 0 0 6 9v.75a8.967 8.967 0 0 1-2.312 6.022c1.733.64 3.56 1.085 5.455 1.31m5.714 0a24.255 24.255 0 0 1-5.714 0m5.714 0a3 3 0 1 1-5.714 0" />
        </svg>
      );
      const EyeIcon = ({ className = 'w-6 h-6' }) => (
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
          <path strokeLinecap="round" strokeLinejoin="round" d="M2.036 12.322a1.012 1.012 0 0 1 0-.639C3.423 7.51 7.36 4.5 12 4.5c4.638 0 8.573 3.007 9.963 7.178.07.207.07.431 0 .639C20.577 16.49 16.64 19.5 12 19.5c-4.638 0-8.573-3.007-9.963-7.178Z" />
          <path strokeLinecap="round" strokeLinejoin="round" d="M15 12a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z" />
        </svg>
      );
      const EyeSlashIcon = ({ className = 'w-6 h-6' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M3.98 8.223A10.477 10.477 0 0 0 1.934 12C3.226 16.338 7.244 19.5 12 19.5c.993 0 1.953-.138 2.863-.395M6.228 6.228A10.45 10.45 0 0 1 12 4.5c4.756 0 8.773 3.162 10.065 7.498a10.523 10.523 0 0 1-4.293 5.572M6.228 6.228 3 3m3.228 3.228 3.65 3.65m7.894 7.894L21 21m-3.228-3.228-3.65-3.65m0 0a3 3 0 1 0-4.243-4.243m4.243 4.243-4.243-4.243" />
          </svg>
      );
      const ArrowDownTrayIcon = ({ className = 'w-6 h-6' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5M16.5 12 12 16.5m0 0L7.5 12m4.5 4.5V3" />
          </svg>
      );
      const ArrowUpTrayIcon = ({ className = 'w-6 h-6' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5m-13.5-9L12 3m0 0 4.5 4.5M12 3v13.5" />
          </svg>
      );
      const ChevronUpDownIcon = ({ className = 'w-6 h-6' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M8.25 15 12 18.75 15.75 15m-7.5-6L12 5.25 15.75 9" />
          </svg>
      );
      const ClipboardDocumentCheckIcon = ({ className = 'w-6 h-6' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M10.125 2.25h-4.5c-1.125 0-2.25.9-2.25 2.25v15c0 1.125.9 2.25 2.25 2.25h10.5c1.125 0 2.25-.9 2.25-2.25v-15c0-1.125-.9-2.25-2.25-2.25H13.5m-3.375 0c1.621 0 2.934.624 3.962 1.554a4.5 4.5 0 0 1 1.933 3.512c.394 2.06.134 4.237-.826 6.052a4.5 4.5 0 0 1-1.46 1.46c-1.814.96-3.992 1.22-6.052.826a4.5 4.5 0 0 1-3.512-1.933 4.5 4.5 0 0 1-1.554-3.962c.31-.95.826-1.833 1.554-2.532A4.5 4.5 0 0 1 6.225 7.5c1.03-.51 2.138-.71 3.265-.493m5.25 1.522c.358.07.709.158 1.05.257m-5.466-2.288a.75.75 0 0 0-1.06 0l-1.06 1.06a.75.75 0 0 0 0 1.06l4.5 4.5a.75.75 0 0 0 1.06 0l2.25-2.25a.75.75 0 0 0 0-1.06l-1.06-1.06a.75.75 0 0 0-1.06 0z" />
          </svg>
      );
      const ArchiveBoxXMarkIcon = ({ className = 'w-6 h-6' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M21.75 6.75v10.5a2.25 2.25 0 0 1-2.25 2.25h-15a2.25 2.25 0 0 1-2.25-2.25V6.75m19.5 0A2.25 2.25 0 0 0 19.5 4.5h-15a2.25 2.25 0 0 0-2.25 2.25m19.5 0v.243a2.25 2.25 0 0 1-1.07 1.916l-7.5 4.615a2.25 2.25 0 0 1-2.36 0L3.32 8.91a2.25 2.25 0 0 1-1.07-1.916V6.75m12 12.75-3.62-2.228a.75.75 0 0 0-.916.03l-3.62 2.228m10.125-10.125L12 13.5m-1.125-1.125L9.75 11.25m3.375 3.375-1.125-1.125m-2.25 2.25 1.125-1.125M12 13.5l1.125 1.125m-2.25-2.25L9.75 11.25m0 0 1.125 1.125M12 13.5l-1.125 1.125m2.25-2.25 1.125-1.125" />
          </svg>
      );
      const CheckCircleIcon = ({ className = 'w-6 h-6', filled = false }) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill={filled ? "currentColor" : "none"} stroke="currentColor" strokeWidth={1.5} className={className}>
          <path strokeLinecap="round" strokeLinejoin="round" d="M9 12.75L11.25 15 15 9.75M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
        </svg>
      );
      const PinIcon = ({ className = 'w-6 h-6', filled = false }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill={filled ? "currentColor" : "none"} viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M19.5 10.5c0 7.142-7.5 11.25-7.5 11.25S4.5 17.642 4.5 10.5a7.5 7.5 0 1 1 15 0Z" />
          </svg>
      );
      const PaintBrushIcon = ({ className = 'w-6 h-6' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M9.53 16.122a3 3 0 0 0-2.818.172l-1.172 1.172a3 3 0 0 0 4.242 4.242l1.172-1.172a3 3 0 0 0 .172-2.818l-.172-.172a3 3 0 0 0-4.242 0l-1.172 1.172a3 3 0 0 0 4.242 4.242l1.172-1.172a3 3 0 0 0 2.818-.172l.172-.172a3 3 0 0 0 0-4.242l-1.172-1.172a3 3 0 0 0-4.242 0Z" />
              <path strokeLinecap="round" strokeLinejoin="round" d="M12.31 16.31 8.865 12.865m0 0a3 3 0 0 1 0-4.242l1.172-1.172a3 3 0 0 1 4.242 0l1.172 1.172a3 3 0 0 1 0 4.242l-1.172 1.172a3 3 0 0 1-4.242 0Zm-2.818-4.242a3 3 0 0 0 0 4.242l1.172 1.172a3 3 0 0 0 4.242 0l1.172-1.172a3 3 0 0 0 0-4.242l-1.172-1.172a3 3 0 0 0-4.242 0l-1.172 1.172Z" />
          </svg>
      );
      const ArrowUturnLeftIcon = ({ className = 'w-6 h-6' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M9 15 3 9m0 0 6-6M3 9h12a6 6 0 0 1 0 12h-3" />
          </svg>
      );
      const Cog6ToothIcon = ({ className = 'w-6 h-6' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M9.594 3.94c.09-.542.56-.94 1.11-.94h2.593c.55 0 1.02.398 1.11.94l.213 1.281c.063.374.26.716.53 1.003l.823.823c.374.374.88.554 1.395.45l1.27-.21c.542-.09.993.256.993.796v2.593c0 .54-.45.986-.993.986l-1.27.21c-.515.104-1.02.276-1.395.65l-.823.823c-.27.287-.467.629-.53 1.003l-.213 1.282c-.09.541-.56.939-1.11.939h-2.593c-.55 0-1.02-.398-1.11-.939l-.213-1.281c-.063-.374-.26-.716-.53-1.003l-.823-.823c-.374-.374-.88-.554-1.395-.45l-1.27.21c-.542.09-.993-.256-.993-.796V8.34c0-.54.45-.986.993.986l1.27-.21c.515-.104 1.02-.276 1.395-.65l.823.823c.27-.287.467.629-.53-1.003l.213-1.282Z" />
              <path strokeLinecap="round" strokeLinejoin="round" d="M15 12a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z" />
          </svg>
      );
      const LockClosedIcon = ({ className = 'w-6 h-6' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M16.5 10.5V6.75a4.5 4.5 0 1 0-9 0v3.75m-.75 11.25h10.5a2.25 2.25 0 0 0 2.25-2.25v-6.75a2.25 2.25 0 0 0-2.25-2.25H6.75a2.25 2.25 0 0 0-2.25 2.25v6.75a2.25 2.25 0 0 0 2.25 2.25Z" />
          </svg>
      );
      const EllipsisVerticalIcon = ({ className = 'w-6 h-6' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M6.75 12a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0ZM12.75 12a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0ZM18.75 12a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0Z" />
          </svg>
      );
      const SunIcon = ({ className = 'w-6 h-6' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M12 3v2.25m6.364.386-1.591 1.591M21 12h-2.25m-.386 6.364-1.591-1.591M12 18.75V21m-4.773-4.227-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 1 1-7.5 0 3.75 3.75 0 0 1 7.5 0Z" />
          </svg>
      );
      const MoonIcon = ({ className = 'w-6 h-6' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M21.752 15.002A9.72 9.72 0 0 1 18 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 0 0 3 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 0 0 9.002-5.998Z" />
          </svg>
      );
      const DocumentDuplicateIcon = ({ className = 'w-6 h-6' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5c0-.621-.504-1.125-1.125-1.125H9.75" />
          </svg>
      );
      const BoldIcon = ({ className = 'w-6 h-6' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M8.25 6.75h4.5a3.375 3.375 0 0 1 3.375 3.375v1.5a3.375 3.375 0 0 1-3.375 3.375h-4.5V6.75Z" />
              <path strokeLinecap="round" strokeLinejoin="round" d="M8.25 15h6a3.375 3.375 0 0 1 3.375 3.375v0a3.375 3.375 0 0 1-3.375 3.375h-6V15Z" />
          </svg>
      );
      const ItalicIcon = ({ className = 'w-6 h-6' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M16.875 3.75h-1.5-1.5-1.5-1.5-1.5M16.875 3.75h-1.5-1.5-1.5-1.5-1.5-1.5m1.5 0-4.5 16.5m1.5-16.5L12 20.25m4.875-16.5-4.5 16.5m0 0H9.375m0 0h-1.5-1.5-1.5-1.5-1.5m1.5 16.5H9.375m-1.5 0H6.375" />
          </svg>
      );
      const HeadingIcon = ({ className = 'w-6 h-6' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M4.5 3.75v16.5M6 3.75h12M6 20.25h12M15 3.75v16.5" />
          </svg>
      );
      const LinkIcon = ({ className = 'w-6 h-6' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M13.19 8.688a4.5 4.5 0 0 1 1.242 7.244l-4.5 4.5a4.5 4.5 0 0 1-6.364-6.364l1.757-1.757m13.35-.622 1.757-1.757a4.5 4.5 0 0 0-6.364-6.364l-4.5 4.5a4.5 4.5 0 0 0 1.242 7.244" />
          </svg>
      );
      const CodeBracketIcon = ({ className = 'w-6 h-6' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M17.25 6.75 22.5 12l-5.25 5.25m-10.5 0L1.5 12l5.25-5.25m7.5-3-4.5 16.5" />
          </svg>
      );
      const ListBulletIcon = ({ className = 'w-6 h-6' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M8.25 6.75h12M8.25 12h12m-12 5.25h12M3.75 6.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0Zm0 5.25a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0Zm0 5.25a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0Z" />
          </svg>
      );
      const ListOrderedIcon = ({ className = 'w-6 h-6' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M8.25 6.75h12M8.25 12h12m-12 5.25h12M3.75 6.75h.007v.008H3.75V6.75Zm.375 0a.375.375 0 1 1-.75 0 .375.375 0 0 1 .75 0ZM3.75 12h.007v.008H3.75V12Zm.375 0a.375.375 0 1 1-.75 0 .375.375 0 0 1 .75 0Zm-.375 5.25h.007v.008H3.75v-.008Zm.375 0a.375.375 0 1 1-.75 0 .375.375 0 0 1 .75 0Z" />
          </svg>
      );
      const QuoteIcon = ({ className = 'w-6 h-6' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M8.25 4.5l-4.5 4.5v10.5h10.5v-10.5l-4.5-4.5H8.25Zm4.5 0-4.5 4.5v10.5h10.5v-10.5l-4.5-4.5h-1.5Z" />
          </svg>
      );
      const ShareIcon = ({ className = 'w-6 h-6' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M7.217 10.907a2.25 2.25 0 1 0 0 2.186m0-2.186c.18.324.283.696.283 1.093s-.103.77-.283 1.093m0-2.186 9.566-5.314m-9.566 7.5 9.566 5.314m0 0a2.25 2.25 0 1 0 0-2.186 2.25 2.25 0 0 0 0 2.186Zm0-12.783a2.25 2.25 0 1 0 0-2.186 2.25 2.25 0 0 0 0 2.186Z" />
          </svg>
      );
      const ClockIcon = ({ className = 'w-6 h-6' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z" />
          </svg>
      );
      const CalendarDaysIcon = ({ className = 'w-6 h-6' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M6.75 3v2.25M17.25 3v2.25M3 18.75V7.5a2.25 2.25 0 0 1 2.25-2.25h13.5A2.25 2.25 0 0 1 21 7.5v11.25m-18 0A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75m-18 0h18M12 12.75h.008v.008H12v-.008Z" />
          </svg>
      );
      const ArrowPathIcon = ({ className = 'w-6 h-6' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M16.023 9.348h4.992v-.001a1.987 1.987 0 0 0-1.523-1.957l-4.992-.001M21 12h-4.992a2.25 2.25 0 0 1-2.25-2.25V6.75M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z" />
              <path strokeLinecap="round" strokeLinejoin="round" d="M15.75 15.75-18 18l.75-4.5" />
          </svg>
      );

      // components/Modal.js
      const Modal = ({ isOpen, onClose, title, children }) => {
        if (!isOpen) {
          return null;
        }

        return (
          <div 
            className="fixed inset-0 bg-black bg-opacity-70 flex justify-center items-center z-50 transition-opacity"
            onClick={onClose}
          >
            <div 
              className="bg-white dark:bg-slate-800 rounded-lg shadow-2xl p-6 w-full max-w-md mx-4 transform transition-all"
              onClick={(e) => e.stopPropagation()}
            >
              <div className="flex justify-between items-center mb-4">
                <h2 className="text-xl font-bold text-cyan-600 dark:text-cyan-400">{title}</h2>
                <button 
                  onClick={onClose}
                  className="text-slate-500 dark:text-slate-400 hover:text-slate-900 dark:hover:text-white transition-colors p-1"
                  aria-label="Close modal"
                >
                  <XMarkIcon className="w-6 h-6" />
                </button>
              </div>
              <div>
                {children}
              </div>
            </div>
          </div>
        );
      };

      // components/Toast.js
      const Toast = ({ toast, onDismiss }) => {
        const [visible, setVisible] = useState(false);

        useEffect(() => {
          if (toast) {
            setVisible(true);
            const timer = setTimeout(() => {
              setVisible(false);
              setTimeout(onDismiss, 300); // Wait for fade out transition
            }, 3000);
            return () => clearTimeout(timer);
          }
        }, [toast, onDismiss]);

        if (!toast) {
          return null;
        }

        const toastStyles = {
          success: 'bg-green-500',
          error: 'bg-red-500',
          info: 'bg-blue-500',
        };

        return (
          <div 
            className={`fixed bottom-5 right-5 p-4 rounded-lg shadow-lg text-white text-base z-50 transition-all duration-300 ${toastStyles[toast.type]} ${visible ? 'opacity-100 translate-x-0' : 'opacity-0 translate-x-10'}`}
          >
            {toast.message}
          </div>
        );
      };

      // components/EditorToolbar.js
      const EditorToolbar = ({ onFormat }) => {
          
          const toolbarButtons = [
              { title: 'Жирный (Ctrl+B)', icon: <BoldIcon className="w-5 h-5"/>, action: () => onFormat('WRAP', '**', '**') },
              { title: 'Курсив (Ctrl+I)', icon: <ItalicIcon className="w-5 h-5"/>, action: () => onFormat('WRAP', '_', '_') },
              { title: 'Заголовок (Ctrl+H)', icon: <HeadingIcon className="w-5 h-5"/>, action: () => onFormat('LINE_PREFIX', '## ') },
              { title: 'Ссылка (Ctrl+K)', icon: <LinkIcon className="w-5 h-5"/>, action: () => onFormat('WRAP', '[', '](url)') },
              { title: 'Цитата', icon: <QuoteIcon className="w-5 h-5"/>, action: () => onFormat('LINE_PREFIX', '> ') },
              { title: 'Код', icon: <CodeBracketIcon className="w-5 h-5"/>, action: () => onFormat('WRAP', '`', '`') },
              { title: 'Маркированный список', icon: <ListBulletIcon className="w-5 h-5"/>, action: () => onFormat('LINE_PREFIX', '- ') },
              { title: 'Нумерованный список', icon: <ListOrderedIcon className="w-5 h-5"/>, action: () => onFormat('LINE_PREFIX', '1. ') },
              { title: 'Чек-лист', icon: <CheckCircleIcon className="w-5 h-5"/>, action: () => onFormat('LINE_PREFIX', '- [ ] ') },
          ];
          
          return (
              <div className="flex items-center space-x-1 bg-slate-100 dark:bg-slate-800 p-2 rounded-t-md border-b border-slate-200 dark:border-slate-700 overflow-x-auto">
                  {toolbarButtons.map(({title, icon, action}) => (
                      <button
                          key={title}
                          type="button"
                          title={title}
                          onClick={action}
                          className="p-2 rounded flex-shrink-0 hover:bg-slate-200 dark:hover:bg-slate-700 text-slate-600 dark:text-slate-300 transition-colors"
                      >
                          {icon}
                      </button>
                  ))}
              </div>
          );
      };
      
      const ActionsDropdown = ({ onOpenCategoryModal, onOpenTemplateModal, onImport, onExport, onDeleteAll }) => {
        const [isOpen, setIsOpen] = useState(false);
        const dropdownRef = useRef(null);

        useEffect(() => {
            const handleClickOutside = (event) => {
                if (dropdownRef.current && !dropdownRef.current.contains(event.target)) {
                    setIsOpen(false);
                }
            };
            document.addEventListener("mousedown", handleClickOutside);
            return () => {
                document.removeEventListener("mousedown", handleClickOutside);
            };
        }, []);

        const menuItems = [
            { label: 'Управлять категориями', icon: <FolderPlusIcon className="w-5 h-5 mr-3"/>, action: onOpenCategoryModal },
            { label: 'Управлять шаблонами', icon: <DocumentDuplicateIcon className="w-5 h-5 mr-3"/>, action: onOpenTemplateModal },
            { label: 'Импортировать данные', icon: <ArrowUpTrayIcon className="w-5 h-5 mr-3"/>, action: onImport },
            { label: 'Экспортировать данные', icon: <ArrowDownTrayIcon className="w-5 h-5 mr-3"/>, action: onExport },
            { label: 'Убрать все в корзину', icon: <ArchiveBoxXMarkIcon className="w-5 h-5 mr-3 text-red-500 dark:text-red-400"/>, action: onDeleteAll, isDestructive: true },
        ];

        return (
            <div ref={dropdownRef} className="relative">
                <button onClick={() => setIsOpen(!isOpen)} className="p-2 text-slate-500 dark:text-slate-300 hover:text-slate-900 dark:hover:text-white transition-colors" title="Дополнительные действия">
                    <EllipsisVerticalIcon className="w-6 h-6" />
                </button>
                {isOpen && (
                    <div className="origin-top-right absolute right-0 mt-2 w-64 rounded-md shadow-lg bg-white dark:bg-slate-700 ring-1 ring-black ring-opacity-5 z-20">
                        <div className="py-1">
                            {menuItems.map(item => (
                                <a
                                    key={item.label}
                                    href="#"
                                    onClick={(e) => { e.preventDefault(); item.action(); setIsOpen(false); }}
                                    className={`flex items-center px-4 py-2 text-sm ${item.isDestructive ? 'text-red-700 dark:text-red-400 hover:bg-red-50 dark:hover:bg-red-900/50' : 'text-slate-700 dark:text-slate-200 hover:bg-slate-100 dark:hover:bg-slate-600'}`}
                                >
                                    {item.icon}
                                    {item.label}
                                </a>
                            ))}
                        </div>
                    </div>
                )}
            </div>
        );
      };

      const ListView = ({ notes, categories, activeFilter, favoritesByCategory, setActiveFilter, onEdit, onDelete, onToggleFavorite, onTogglePin, onChangeCategory, onOpenCategoryModal, onOpenSettingsModal, onOpenTemplateModal, searchQuery, onSearchChange, sortOrder, onSortChange, onExport, onImport, isSelectionMode, selectedNoteIds, onToggleSelectionMode, onSelectNote, onDeleteAll, onNavigate, trashedCount, onToggleChecklistItem }) => {
          
          const renderContent = () => {
              const hasNotes = activeFilter === 'ALL' ? notes.length > 0 : favoritesByCategory.some(g => g.notes.length > 0);

              const noteCardProps = {
                  categories,
                  onEdit,
                  onDelete,
                  onToggleFavorite,
                  onTogglePin,
                  onChangeCategory,
                  isSelectionMode,
                  onSelect: onSelectNote,
                  onToggleChecklistItem,
              };

              if (hasNotes) {
                  if (activeFilter === 'FAVORITES') {
                      return favoritesByCategory.map(({ category, notes: groupNotes }) => (
                          <div key={category?.id || 'uncategorized'} className="mb-8">
                              <h2 className="text-xl font-semibold text-cyan-500 dark:text-cyan-300 mb-3 border-b-2 border-slate-200 dark:border-slate-700 pb-2">{category?.name || 'Без категории'}</h2>
                              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                  {groupNotes.map(note => <NoteCard key={note.id} note={note} isSelected={selectedNoteIds.includes(note.id)} {...noteCardProps}/>)}
                              </div>
                          </div>
                      ));
                  }
                  return (
                      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                          {notes.map(note => <NoteCard key={note.id} note={note} isSelected={selectedNoteIds.includes(note.id)} {...noteCardProps}/>)}
                      </div>
                  );
              }

              if (searchQuery.trim() !== '') {
                  return (
                      <div className="text-center py-12">
                          <SearchIcon className="w-16 h-16 mx-auto text-slate-400 dark:text-slate-600 mb-4" />
                          <h3 className="text-xl font-semibold text-slate-600 dark:text-slate-400">Ничего не найдено</h3>
                          <p className="text-slate-500 dark:text-slate-500">Попробуйте изменить поисковый запрос.</p>
                      </div>
                  );
              }
              
              if (activeFilter === 'FAVORITES') {
                  return (
                      <div className="text-center py-12">
                          <StarIcon className="w-16 h-16 mx-auto text-slate-400 dark:text-slate-600 mb-4" />
                          <h3 className="text-xl font-semibold text-slate-600 dark:text-slate-400">В избранном пусто</h3>
                          <p className="text-slate-500">Нажмите на звездочку, чтобы добавить заметку сюда.</p>
                      </div>
                  );
              }

              return (
                  <div className="text-center py-12">
                      <PencilIcon className="w-16 h-16 mx-auto text-slate-400 dark:text-slate-600 mb-4" />
                      <h3 className="text-xl font-semibold text-slate-600 dark:text-slate-400">Заметок пока нет</h3>
                      <p className="text-slate-500">Нажмите на "+", чтобы создать первую заметку.</p>
                  </div>
              );
          };

          return (
              <div className={isSelectionMode ? 'pb-24' : ''}>
                  <header className="relative flex justify-between items-center py-4 mb-4 border-b border-slate-200 dark:border-slate-700">
                      <h1 className="text-2xl sm:text-3xl font-bold text-cyan-600 dark:text-cyan-400 truncate pr-2">Умный Блокнот</h1>
                      <div className="flex items-center space-x-1 sm:space-x-2">
                           <button onClick={onOpenSettingsModal} className="p-2 text-slate-500 dark:text-slate-300 hover:text-slate-900 dark:hover:text-white transition-colors" title="Настройки">
                              <Cog6ToothIcon className="w-6 h-6" />
                          </button>
                          <button onClick={() => onNavigate('TRASH')} className="relative p-2 text-slate-500 dark:text-slate-300 hover:text-slate-900 dark:hover:text-white transition-colors" title="Корзина">
                              <TrashIcon className="w-6 h-6" />
                              {trashedCount > 0 && (
                                  <span className="absolute top-0 right-0 block h-4 w-4 rounded-full bg-red-500 text-white text-xs font-bold ring-2 ring-white dark:ring-slate-900">{trashedCount}</span>
                              )}
                          </button>
                          <button onClick={onToggleSelectionMode} className={`p-2 rounded-md transition-colors ${isSelectionMode ? 'bg-cyan-600 text-white' : 'text-slate-500 dark:text-slate-300 hover:text-slate-900 dark:hover:text-white'}`} title={isSelectionMode ? "Отменить выбор" : "Выбрать заметки"}>
                              <ClipboardDocumentCheckIcon className="w-6 h-6" />
                          </button>
                          <ActionsDropdown
                              onOpenCategoryModal={onOpenCategoryModal}
                              onOpenTemplateModal={onOpenTemplateModal}
                              onImport={onImport}
                              onExport={onExport}
                              onDeleteAll={onDeleteAll}
                          />
                      </div>
                  </header>
                  
                  <div className="relative mb-4">
                      <span className="absolute left-4 top-1/2 -translate-y-1/2 text-slate-400 dark:text-slate-400">
                        <SearchIcon className="w-5 h-5" />
                      </span>
                      <input
                        type="search"
                        placeholder="Поиск по названию или тексту..."
                        value={searchQuery}
                        onChange={(e) => onSearchChange(e.target.value)}
                        className="w-full bg-slate-100 dark:bg-slate-800 rounded-full py-2 pr-4 pl-11 text-slate-900 dark:text-white placeholder-slate-500 dark:placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-cyan-500 transition"
                      />
                  </div>

                  <div className="relative flex flex-wrap gap-2 justify-between items-center mb-6">
                      <div className="flex space-x-2">
                          <button onClick={() => setActiveFilter('ALL')} className={`px-4 py-2 rounded-full text-sm font-semibold transition-colors ${activeFilter === 'ALL' ? 'bg-cyan-600 text-white' : 'bg-slate-200 dark:bg-slate-700 text-slate-700 dark:text-slate-300 hover:bg-slate-300 dark:hover:bg-slate-600'}`}>Все заметки</button>
                          <button onClick={() => setActiveFilter('FAVORITES')} className={`px-4 py-2 rounded-full text-sm font-semibold transition-colors ${activeFilter === 'FAVORITES' ? 'bg-cyan-600 text-white' : 'bg-slate-200 dark:bg-slate-700 text-slate-700 dark:text-slate-300 hover:bg-slate-300 dark:hover:bg-slate-600'}`}>Избранное</button>
                      </div>
                       {activeFilter === 'ALL' && <SortDropdown value={sortOrder} onChange={onSortChange} />}
                  </div>
                  
                  <main>
                      {renderContent()}
                  </main>
              </div>
          );
      };

      const TrashView = ({ notes, onRestore, onDelete, onEmptyTrash, onNavigate, isSelectionMode, selectedNoteIds, onToggleSelectionMode, onSelectNote, onDeleteSelected }) => {
          return (
              <div className={isSelectionMode ? 'pb-24' : ''}>
                  <header className="flex justify-between items-center py-4 mb-6 border-b border-slate-200 dark:border-slate-700">
                      <div className="flex items-center">
                          <button onClick={() => onNavigate('LIST')} className="p-2 mr-4 text-slate-500 dark:text-slate-400 hover:text-slate-900 dark:hover:text-white transition-colors">
                              <ArrowLeftIcon className="w-6 h-6" />
                          </button>
                          <h1 className="text-3xl font-bold text-cyan-600 dark:text-cyan-400">Корзина</h1>
                      </div>
                      <div className="flex items-center space-x-2">
                          <button onClick={onToggleSelectionMode} className={`p-2 rounded-md transition-colors ${isSelectionMode ? 'bg-cyan-600 text-white' : 'text-slate-500 dark:text-slate-300 hover:text-slate-900 dark:hover:text-white'}`} title={isSelectionMode ? "Отменить выбор" : "Выбрать заметки"}>
                              <ClipboardDocumentCheckIcon className="w-6 h-6" />
                          </button>
                           <button onClick={onEmptyTrash} disabled={notes.length === 0} className="p-2 text-slate-500 dark:text-slate-300 hover:text-red-500 dark:hover:text-red-400 transition-colors disabled:text-slate-300 dark:disabled:text-slate-600 disabled:cursor-not-allowed" title="Очистить корзину">
                              <ArchiveBoxXMarkIcon className="w-6 h-6" />
                          </button>
                      </div>
                  </header>
                  
                  <main>
                      {notes.length > 0 ? (
                          <div className="space-y-4">
                              {notes.map(note => {
                                  const isSelected = selectedNoteIds.includes(note.id);
                                  return (
                                      <div 
                                          key={note.id} 
                                          className={`bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-lg p-4 flex justify-between items-center shadow-md transition-all ${isSelectionMode ? 'cursor-pointer' : ''} ${isSelected ? 'ring-2 ring-cyan-500 bg-cyan-50 dark:bg-slate-700' : ''}`}
                                          onClick={() => isSelectionMode && onSelectNote(note.id)}
                                      >
                                          <div className="truncate">
                                              <h3 className="font-bold truncate">{note.title}</h3>
                                              <p className="text-sm text-slate-500 dark:text-slate-400">Удалено: {new Date(note.deletedAt).toLocaleString()}</p>
                                          </div>
                                          {!isSelectionMode && (
                                              <div className="flex items-center space-x-2 flex-shrink-0 ml-4">
                                                  <button onClick={() => onRestore(note.id)} className="p-2 rounded-full text-slate-500 dark:text-slate-400 hover:text-green-500 dark:hover:text-green-400 transition-colors" title="Восстановить">
                                                      <ArrowUturnLeftIcon className="w-5 h-5"/>
                                                  </button>
                                                  <button onClick={() => onDelete(note.id)} className="p-2 rounded-full text-slate-500 dark:text-slate-400 hover:text-red-500 dark:hover:text-red-400 transition-colors" title="Удалить навсегда">
                                                      <TrashIcon className="w-5 h-5"/>
                                                  </button>
                                              </div>
                                          )}
                                          {isSelectionMode && (
                                              <div className="text-cyan-400 pointer-events-none">
                                                  <CheckCircleIcon className="w-6 h-6" filled={isSelected} />
                                              </div>
                                          )}
                                      </div>
                                  );
                              })}
                          </div>
                      ) : (
                          <div className="text-center py-12">
                              <TrashIcon className="w-16 h-16 mx-auto text-slate-400 dark:text-slate-600 mb-4" />
                              <h3 className="text-xl font-semibold text-slate-600 dark:text-slate-400">Корзина пуста</h3>
                              <p className="text-slate-500">Удаленные заметки будут отображаться здесь.</p>
                          </div>
                      )}
                  </main>
              </div>
          );
      };

      const SortDropdown = ({ value, onChange }) => {
          const [isOpen, setIsOpen] = useState(false);
          const dropdownRef = useRef(null);
          const options = [
              { value: 'updatedAt_desc', label: 'Сначала новые обновленные' },
              { value: 'updatedAt_asc', label: 'Сначала старые обновленные' },
              { value: 'createdAt_desc', label: 'Сначала новые созданные' },
              { value: 'createdAt_asc', label: 'Сначала старые созданные' },
              { value: 'title_asc', label: 'По названию (А-Я)' },
              { value: 'title_desc', label: 'По названию (Я-А)' },
          ];
          const selectedLabel = options.find(opt => opt.value === value)?.label;

          useEffect(() => {
              const handleClickOutside = (event) => {
                  if (dropdownRef.current && !dropdownRef.current.contains(event.target)) {
                      setIsOpen(false);
                  }
              };
              document.addEventListener('mousedown', handleClickOutside);
              return () => document.removeEventListener('mousedown', handleClickOutside);
          }, []);

          return (
              <div ref={dropdownRef} className="relative inline-block text-left">
                  <div>
                      <button
                          type="button"
                          className="inline-flex justify-center w-full rounded-md border border-slate-300 dark:border-slate-600 shadow-sm px-4 py-2 bg-white dark:bg-slate-700 text-sm font-medium text-slate-700 dark:text-slate-300 hover:bg-slate-50 dark:hover:bg-slate-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-slate-100 dark:focus:ring-offset-slate-800 focus:ring-cyan-500"
                          onClick={() => setIsOpen(!isOpen)}
                      >
                          {selectedLabel}
                          <ChevronUpDownIcon className="-mr-1 ml-2 h-5 w-5" />
                      </button>
                  </div>
                  {isOpen && (
                      <div
                        className="origin-top-left sm:origin-top-right absolute left-0 sm:left-auto sm:right-0 mt-2 w-52 sm:w-56 rounded-md shadow-lg bg-white dark:bg-slate-700 ring-1 ring-black ring-opacity-5 z-10">
                          <div className="py-1" role="menu" aria-orientation="vertical">
                              {options.map(option => (
                                   <a
                                      key={option.value}
                                      href="#"
                                      className={`block px-4 py-2 text-sm ${value === option.value ? 'bg-cyan-600 text-white' : 'text-slate-700 dark:text-slate-300 hover:bg-slate-100 dark:hover:bg-slate-600'}`}
                                      onClick={(e) => {
                                          e.preventDefault();
                                          onChange(option.value);
                                          setIsOpen(false);
                                      }}
                                  >
                                      {option.label}
                                  </a>
                              ))}
                          </div>
                      </div>
                  )}
              </div>
          );
      };

      const NoteCard = ({ note, categories, onEdit, onDelete, onToggleFavorite, onTogglePin, onChangeCategory, isSelectionMode, isSelected, onSelect, onToggleChecklistItem }) => {

          const handleCardClick = (e) => {
              const target = e.target;

              if (target.tagName === 'INPUT' && target.type === 'checkbox') {
                  e.preventDefault(); 
                  const taskListItem = target.closest('li.task-list-item');
                  if (taskListItem) {
                      const itemIndexStr = taskListItem.getAttribute('data-item-index');
                      if (itemIndexStr !== null) {
                          const itemIndex = parseInt(itemIndexStr, 10);
                          onToggleChecklistItem(note.id, itemIndex);
                      }
                  }
                  return;
              }
              
              if (target.closest('button') || target.closest('select')) {
                  return;
              }

              if (isSelectionMode) {
                  onSelect(note.id);
              } else {
                  onEdit(note);
              }
          };
          
          const colorClassMap = {
              red: 'bg-red-500',
              yellow: 'bg-yellow-500',
              green: 'bg-green-500',
              blue: 'bg-blue-500',
              purple: 'bg-purple-500',
          };
          
          const colorStripeClass = note.color && colorClassMap[note.color] ? colorClassMap[note.color] : 'bg-transparent';

          return (
              <div 
                  className={`bg-white dark:bg-slate-800 rounded-lg shadow-md dark:shadow-none border border-slate-200 dark:border-slate-700 transition-all duration-200 relative overflow-hidden group ${!isSelectionMode ? 'hover:shadow-cyan-400/10 dark:hover:shadow-cyan-500/20 hover:-translate-y-1 cursor-pointer' : ''} ${isSelected ? 'ring-2 ring-cyan-500' : ''}`}
                  onClick={handleCardClick}
              >
                  <div className={`absolute left-0 top-0 bottom-0 w-1 ${colorStripeClass}`}></div>
                  
                  <div className={`pl-5 pr-4 py-4 flex flex-col justify-between h-full ${isSelected ? 'bg-cyan-50 dark:bg-slate-700/50' : ''}`}>
                      <div>
                          {isSelectionMode && (
                              <div className="absolute top-3 right-3 text-cyan-500 dark:text-cyan-400 z-10 pointer-events-none">
                                  <CheckCircleIcon className="w-6 h-6" filled={isSelected} />
                              </div>
                          )}
                           {note.isPinned && !isSelectionMode && (
                              <div className="absolute top-3 right-3 text-slate-400 dark:text-slate-500 z-10">
                                  <PinIcon className="w-5 h-5" filled={true}/>
                              </div>
                          )}
                          <div className={`${isSelectionMode ? 'pointer-events-none' : ''}`}>
                              <h3 className="text-lg font-bold text-slate-900 dark:text-slate-100 truncate mb-2 pr-8">{note.title}</h3>
                              <div 
                                className="text-slate-600 dark:text-slate-400 text-sm mb-4 break-words markdown-content"
                                dangerouslySetInnerHTML={parseMarkdownWithChecklists(note.content, note.id)}
                              />
                          </div>
                      </div>
                      <div>
                          {note.reminder?.nextDueDate && (
                             <div className="flex items-center text-xs text-amber-600 dark:text-amber-400 mt-2 mb-2 p-2 bg-amber-100/50 dark:bg-slate-700/50 rounded-md">
                                  <BellIcon className="w-4 h-4 mr-2 flex-shrink-0" />
                                  <span>{new Date(note.reminder.nextDueDate).toLocaleString('ru', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' })}</span>
                              </div>
                          )}
                          {note.isFavorite && (
                              <select
                                  value={note.categoryId || ''}
                                  onChange={(e) => onChangeCategory(note.id, e.target.value || null)}
                                  className="w-full bg-slate-100 dark:bg-slate-700 text-slate-800 dark:text-white text-sm rounded-md px-2 py-1 mb-3 focus:outline-none focus:ring-2 focus:ring-cyan-500"
                                  onClick={(e) => e.stopPropagation()}
                                  disabled={isSelectionMode}
                              >
                                  <option value="">Без категории</option>
                                  {categories.map(cat => <option key={cat.id} value={cat.id}>{cat.name}</option>)}
                              </select>
                          )}
                          <div className="flex justify-between items-center">
                              <p className="text-xs text-slate-500">{new Date(note.updatedAt).toLocaleString()}</p>
                              {!isSelectionMode && (
                                  <div className="flex items-center space-x-2">
                                      <button onClick={(e) => { e.stopPropagation(); onTogglePin(note.id); }} className={`p-1 rounded-full transition-colors ${note.isPinned ? 'text-cyan-500 dark:text-cyan-400 hover:text-cyan-600 dark:hover:text-cyan-300' : 'text-slate-400 dark:text-slate-500 hover:text-cyan-500 dark:hover:text-cyan-400'}`}>
                                          <PinIcon filled={note.isPinned} className="w-5 h-5"/>
                                      </button>
                                      <button onClick={(e) => { e.stopPropagation(); onToggleFavorite(note.id); }} className={`p-1 rounded-full transition-colors ${note.isFavorite ? 'text-yellow-500 dark:text-yellow-400 hover:text-yellow-600 dark:hover:text-yellow-300' : 'text-slate-400 dark:text-slate-500 hover:text-yellow-500 dark:hover:text-yellow-400'}`}>
                                          <StarIcon filled={note.isFavorite} className="w-5 h-5"/>
                                      </button>
                                      <button onClick={(e) => { e.stopPropagation(); onEdit(note); }} className="p-1 rounded-full text-slate-400 dark:text-slate-500 hover:text-cyan-500 dark:hover:text-cyan-400 transition-colors">
                                          <PencilIcon className="w-5 h-5"/>
                                      </button>
                                      <button onClick={(e) => { e.stopPropagation(); onDelete(note.id); }} className="p-1 rounded-full text-slate-400 dark:text-slate-500 hover:text-red-500 dark:hover:text-red-400 transition-colors">
                                          <TrashIcon className="w-5 h-5"/>
                                      </button>
                                  </div>
                              )}
                          </div>
                      </div>
                  </div>
              </div>
          );
      }

      const NoteEditor = ({ note, categories, templates, onSave, onCancel, theme, showToast }) => {
        const [title, setTitle] = useState(note?.title || '');
        const [content, setContent] = useState(note?.content || '');
        const [isFavorite, setIsFavorite] = useState(note?.isFavorite || false);
        const [categoryId, setCategoryId] = useState(note?.categoryId || null);
        const [reminder, setReminder] = useState(note?.reminder || null);
        const [journal, setJournal] = useState(note?.journal || []);
        const [color, setColor] = useState(note?.color || null);
        const [showPreview, setShowPreview] = useState(false);
        const [isTemplateSelectorOpen, setTemplateSelectorOpen] = useState(false);
        const [isReminderModalOpen, setReminderModalOpen] = useState(false);
        const textareaRef = useRef(null);
        const [isExportMenuOpen, setExportMenuOpen] = useState(false);
        const exportMenuRef = useRef(null);
        const exportButtonRef = useRef(null);

        useEffect(() => {
          if(!isFavorite) {
            setCategoryId(null);
          }
        }, [isFavorite])

        useEffect(() => {
          const handleClickOutside = (event) => {
              if (exportMenuRef.current && !exportMenuRef.current.contains(event.target) && !exportButtonRef.current?.contains(event.target)) {
                  setExportMenuOpen(false);
              }
          };
          document.addEventListener("mousedown", handleClickOutside);
          return () => {
              document.removeEventListener("mousedown", handleClickOutside);
          };
        }, []);

        const handleSaveClick = () => {
          if(title.trim() === '') {
            showToast('Заголовок не может быть пустым.', 'error');
            return;
          }
          onSave({ title, content, isFavorite, categoryId, reminder, journal, color });
        };
        
        const handleApplyTemplate = (template) => {
          setTitle(template.title);
          setContent(template.content);
          setTemplateSelectorOpen(false);
        };

        const addJournalEntry = () => {
          const newEntry = {
              id: Date.now().toString(),
              createdAt: Date.now(),
              content: ''
          };
          setJournal([newEntry, ...journal]);
        };

        const updateJournalEntry = (id, newContent) => {
          setJournal(journal.map(entry => entry.id === id ? {...entry, content: newContent} : entry));
        };

        const deleteJournalEntry = (id) => {
          setJournal(journal.filter(entry => entry.id !== id));
        };

        const handleExportNote = async (format) => {
          const sanitizedTitle = (title.trim() || 'Без названия').replace(/[\\/:"*?<>|]/g, '_');
          
          if (format === 'pdf') {
              showToast('Генерация PDF...', 'info');
              try {
                  const { jsPDF } = window.jspdf;
                  const filename = `${sanitizedTitle}.pdf`;
                  const bodyHtml = window.marked.parse(content, { gfm: true });
                  const sanitizedBody = window.DOMPurify.sanitize(bodyHtml);
                  const isDark = theme === 'dark';
                  const colorHexMap = { red: '#ef4444', yellow: '#eab308', green: '#22c55e', blue: '#3b82f6', purple: '#8b5cf6' };
                  const noteBorderColor = color ? colorHexMap[color] : 'transparent';
                  const htmlStyles = `
                    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.6; padding: 0; margin: 0; background-color: ${isDark ? '#0f172a' : '#ffffff'}; color: ${isDark ? '#e2e8f0' : '#1e293b'}; -webkit-font-smoothing: antialiased; }
                    .pdf-container { padding: 20px; width: 800px; box-sizing: border-box; }
                    .markdown-content { max-width: 100%; }
                    .markdown-content h1 { font-size: 1.5em; border-bottom: 1px solid ${isDark ? '#334155' : '#e2e8f0'}; padding-bottom: .3em; }
                    .markdown-content a { color: ${isDark ? '#22d3ee' : '#0891b2'}; text-decoration: none; }
                    .markdown-content blockquote { border-left: 4px solid ${isDark ? '#475569' : '#cbd5e1'}; padding-left: 1em; margin-left: 0; font-style: italic; color: ${isDark ? '#94a3b8' : '#475569'}; }
                    .markdown-content code { background-color: ${isDark ? '#1e293b' : '#f1f5f9'}; padding: 0.2em 0.4em; border-radius: 4px; font-family: monospace; }
                    .markdown-content pre { background-color: ${isDark ? '#1e293b' : '#f1f5f9'}; padding: 1em; border-radius: 6px; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word; }
                  `;
                  const printElement = document.createElement('div');
                  printElement.style.position = 'absolute';
                  printElement.style.left = '-9999px';
                  printElement.innerHTML = `
                    <style>${htmlStyles}</style>
                    <body class="${isDark ? 'dark' : ''}">
                      <div class="pdf-container" style="border-left: 5px solid ${noteBorderColor};">
                          <div class="markdown-content"><h1>${title}</h1>${sanitizedBody}</div>
                      </div>
                    </body>`;
                  document.body.appendChild(printElement);
                  
                  const canvas = await window.html2canvas(printElement.querySelector('.pdf-container'), { scale: 2, useCORS: true, backgroundColor: isDark ? '#0f172a' : '#ffffff' });
                  document.body.removeChild(printElement);

                  const imgData = canvas.toDataURL('image/png');
                  const pdf = new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'a4' });
                  const pdfWidth = pdf.internal.pageSize.getWidth();
                  const imgProps = pdf.getImageProperties(imgData);
                  const imgHeight = (imgProps.height * pdfWidth) / imgProps.width;
                  let heightLeft = imgHeight;
                  pdf.addImage(imgData, 'PNG', 0, 0, pdfWidth, imgHeight);
                  heightLeft -= pdf.internal.pageSize.getHeight();
                  while (heightLeft > 0) {
                      let position = -pdf.internal.pageSize.getHeight();
                      pdf.addPage();
                      pdf.addImage(imgData, 'PNG', 0, position, pdfWidth, imgHeight);
                      heightLeft -= pdf.internal.pageSize.getHeight();
                  }
                  pdf.save(filename);
                  showToast(`Заметка экспортирована как .pdf`, 'success');
              } catch (error) {
                  console.error('PDF Export failed:', error);
                  showToast('Ошибка при экспорте в PDF.', 'error');
              }
              setExportMenuOpen(false);
              return;
          }
          
          let contentToExport = '';
          let mimeType = 'text/plain;charset=utf-8;';
          const filename = `${sanitizedTitle}.${format}`;

          switch (format) {
              case 'md': contentToExport = content; mimeType = 'text/markdown;charset=utf-8;'; break;
              case 'txt': 
                const htmlFromMd = window.marked.parse(content);
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = window.DOMPurify.sanitize(htmlFromMd);
                contentToExport = tempDiv.textContent || '';
                break;
              case 'html':
                const bodyHtml = window.marked.parse(content, { gfm: true });
                const sanitizedBody = window.DOMPurify.sanitize(bodyHtml);
                const isDark = theme === 'dark';
                const htmlStyles = `body { font-family: sans-serif; line-height: 1.6; padding: 2em; background-color: ${isDark ? '#0f172a' : '#ffffff'}; color: ${isDark ? '#e2e8f0' : '#1e293b'}; } .markdown-content { max-width: 720px; margin: 0 auto; }`;
                contentToExport = `<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><title>${sanitizedTitle}</title><style>${htmlStyles}</style></head><body class="${isDark ? 'dark' : ''}"><div class="markdown-content"><h1>${title}</h1>${sanitizedBody}</div></body></html>`;
                mimeType = 'text/html;charset=utf-8;';
                break;
          }

          const blob = new Blob([contentToExport], { type: mimeType });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
          setExportMenuOpen(false);
          showToast(`Заметка экспортирована как .${format}`, 'success');
        };
        
        const handleShareNote = async () => {
          const noteData = { title: title.trim(), content: content, color: color };
          const jsonString = JSON.stringify(noteData);
          const encodedData = btoa(unescape(encodeURIComponent(jsonString)));
          const shareUrl = `${window.location.origin}${window.location.pathname}#/import-note/${encodeURIComponent(encodedData)}`;

          if (navigator.share) {
              try {
                  await navigator.share({ title: `Заметка: ${noteData.title}`, text: `Посмотри мою заметку: "${noteData.title}"`, url: shareUrl });
                  showToast('Заметка отправлена!', 'success');
              } catch (error) { console.error('Error sharing:', error); }
          } else {
              navigator.clipboard.writeText(shareUrl).then(() => {
                  showToast('Ссылка на заметку скопирована в буфер обмена!', 'info');
              }, () => {
                  showToast('Не удалось скопировать ссылку.', 'error');
              });
          }
        };

        const applyFormat = (type, prefix, suffix = '') => {
              const textarea = textareaRef.current;
              if (!textarea) return;
              const { selectionStart: start, selectionEnd: end, value: text } = textarea;
              const selectedText = text.substring(start, end);
              let newContent, newSelectionStart, newSelectionEnd;
              if (type === 'WRAP') {
                  newContent = `${text.substring(0, start)}${prefix}${selectedText}${suffix}${text.substring(end)}`;
                  newSelectionStart = selectedText ? start + prefix.length : start + prefix.length;
                  newSelectionEnd = selectedText ? end + prefix.length : start + prefix.length;
              } else if (type === 'LINE_PREFIX') {
                  let lineStart = start;
                  while(lineStart > 0 && text[lineStart - 1] !== '\n') lineStart--;
                  const lines = text.substring(lineStart, end).split('\n');
                  const modifiedLines = lines.map(line => `${prefix}${line}`).join('\n');
                  newContent = text.substring(0, lineStart) + modifiedLines + text.substring(end);
                  newSelectionStart = start + prefix.length;
                  newSelectionEnd = end + (prefix.length * lines.length);
              }
              setContent(newContent);
              setTimeout(() => { textarea.focus(); textarea.setSelectionRange(newSelectionStart, newSelectionEnd); }, 0);
          };
          
        const handleKeyDown = (e) => {
          if (e.ctrlKey || e.metaKey) {
              let applied = true;
              switch (e.key) {
                  case 'b': applyFormat('WRAP', '**', '**'); break;
                  case 'i': applyFormat('WRAP', '_', '_'); break;
                  case 'h': applyFormat('LINE_PREFIX', '## '); break;
                  case 'k': applyFormat('WRAP', '[', '](url)'); break;
                  default: applied = false;
              }
              if (applied) e.preventDefault();
          }
        }
        
        return (
          <div className="animate-fade-in">
              <header className="relative flex items-center justify-between py-4 mb-6 flex-wrap gap-2">
                <div className='flex items-center'>
                    <button onClick={onCancel} className="p-2 mr-2 sm:mr-4 text-slate-500 dark:text-slate-400 hover:text-slate-900 dark:hover:text-white transition-colors"><ArrowLeftIcon className="w-6 h-6"/></button>
                    <h2 className="text-xl sm:text-3xl font-bold text-cyan-600 dark:text-cyan-400 truncate pr-2">{note ? 'Редактировать заметку' : 'Новая заметка'}</h2>
                </div>
                <div className="flex items-center space-x-1 sm:space-x-2">
                     <button onClick={() => setShowPreview(!showPreview)} className={`p-2 rounded-md transition-colors ${showPreview ? 'bg-cyan-600 text-white' : 'text-slate-500 dark:text-slate-400 hover:bg-slate-200 dark:hover:bg-slate-700'}`} title={showPreview ? "Редактировать" : "Предпросмотр"}>
                        {showPreview ? <PencilIcon className="w-5 h-5"/> : <EyeIcon className="w-5 h-5"/>}
                    </button>
                    <div ref={exportMenuRef} className="relative">
                         <button ref={exportButtonRef} onClick={() => setExportMenuOpen(prev => !prev)} className="p-2 rounded-md text-slate-500 dark:text-slate-400 hover:bg-slate-200 dark:hover:bg-slate-700 transition-colors" title="Экспорт"><ArrowDownTrayIcon className="w-5 h-5"/></button>
                         {isExportMenuOpen && (
                            <div className="origin-top-left sm:origin-top-right absolute left-0 sm:left-auto sm:right-0 mt-2 w-48 rounded-md shadow-lg bg-white dark:bg-slate-700 ring-1 ring-black ring-opacity-5 z-30">
                                <div className="py-1">
                                    <a href="#" onClick={(e) => { e.preventDefault(); handleExportNote('pdf'); }} className="block px-4 py-2 text-sm text-slate-700 dark:text-slate-200 hover:bg-slate-100 dark:hover:bg-slate-600">как PDF (.pdf)</a>
                                    <a href="#" onClick={(e) => { e.preventDefault(); handleExportNote('md'); }} className="block px-4 py-2 text-sm text-slate-700 dark:text-slate-200 hover:bg-slate-100 dark:hover:bg-slate-600">как Markdown (.md)</a>
                                    <a href="#" onClick={(e) => { e.preventDefault(); handleExportNote('html'); }} className="block px-4 py-2 text-sm text-slate-700 dark:text-slate-200 hover:bg-slate-100 dark:hover:bg-slate-600">как HTML (.html)</a>
                                    <a href="#" onClick={(e) => { e.preventDefault(); handleExportNote('txt'); }} className="block px-4 py-2 text-sm text-slate-700 dark:text-slate-200 hover:bg-slate-100 dark:hover:bg-slate-600">как Текст (.txt)</a>
                                </div>
                            </div>
                        )}
                    </div>
                    <button onClick={handleShareNote} className="p-2 rounded-md text-slate-500 dark:text-slate-400 hover:bg-slate-200 dark:hover:bg-slate-700 transition-colors" title="Поделиться"><ShareIcon className="w-5 h-5"/></button>
                    <button onClick={handleSaveClick} className="px-4 py-2 rounded-md bg-cyan-600 hover:bg-cyan-500 text-white font-semibold transition-colors flex items-center space-x-2"><CheckIcon className="w-5 h-5"/><span>Сохранить</span></button>
                </div>
              </header>
              <div className="bg-white dark:bg-slate-800 rounded-lg border border-slate-200 dark:border-slate-700 shadow-sm">
                <div className="p-4 border-b border-slate-200 dark:border-slate-700"><input type="text" placeholder="Заголовок..." value={title} onChange={(e) => setTitle(e.target.value)} className="w-full text-2xl font-bold bg-transparent text-slate-900 dark:text-white placeholder-slate-400 dark:placeholder-slate-500 focus:outline-none"/></div>
                {!showPreview && <EditorToolbar onFormat={applyFormat} />}
                <div className="p-4">
                  {showPreview ? (<div className="prose dark:prose-invert max-w-none markdown-content" dangerouslySetInnerHTML={parseMarkdownWithChecklists(content, note?.id || 'new-note-preview')}/>) 
                  : (<textarea ref={textareaRef} placeholder="Начните писать..." value={content} onChange={(e) => setContent(e.target.value)} onKeyDown={handleKeyDown} className="w-full h-96 bg-transparent text-slate-700 dark:text-slate-300 placeholder-slate-400 dark:placeholder-slate-500 focus:outline-none resize-y"/>)}
                </div>
                <footer className="p-4 border-t border-slate-200 dark:border-slate-700 bg-slate-50 dark:bg-slate-800/50 rounded-b-lg flex flex-wrap gap-4 justify-between items-center">
                    <div className="flex items-center space-x-2">
                         <button onClick={() => setTemplateSelectorOpen(true)} className="flex items-center space-x-2 text-sm px-3 py-2 rounded-md bg-slate-200 dark:bg-slate-700 hover:bg-slate-300 dark:hover:bg-slate-600 text-slate-700 dark:text-slate-200 font-semibold transition-colors" title="Применить шаблон"><DocumentDuplicateIcon className="w-4 h-4" /><span>Шаблон</span></button>
                        <button onClick={() => setReminderModalOpen(true)} className={`flex items-center space-x-2 text-sm px-3 py-2 rounded-md font-semibold transition-colors ${reminder ? 'bg-cyan-100 dark:bg-cyan-900/50 text-cyan-700 dark:text-cyan-300' : 'bg-slate-200 dark:bg-slate-700 hover:bg-slate-300 dark:hover:bg-slate-600 text-slate-700 dark:text-slate-200'}`} title="Настроить напоминание"><BellIcon className="w-4 h-4" filled={!!reminder} /><span>Напоминание</span></button>
                    </div>
                    <div className="flex items-center space-x-2">
                         <ColorPicker selectedColor={color} onSelectColor={setColor} />
                         <button onClick={() => setIsFavorite(!isFavorite)} className={`flex items-center space-x-2 px-3 py-2 rounded-md font-semibold text-sm transition-colors ${isFavorite ? 'bg-yellow-400/20 text-yellow-600 dark:text-yellow-400 hover:bg-yellow-400/30' : 'bg-slate-200 dark:bg-slate-700 text-slate-700 dark:text-slate-200 hover:bg-slate-300 dark:hover:bg-slate-600'}`}><StarIcon filled={isFavorite} className="w-4 h-4"/><span>{isFavorite ? 'В избранном' : 'В избранное'}</span></button>
                    </div>
                </footer>
                {isFavorite && (
                     <div className="p-4 border-t border-slate-200 dark:border-slate-700">
                        <label htmlFor="category-select" className="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-1">Категория</label>
                        <select id="category-select" value={categoryId || ''} onChange={(e) => setCategoryId(e.target.value || null)} className="w-full bg-slate-100 dark:bg-slate-700 text-slate-800 dark:text-white rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-cyan-500"><option value="">Без категории</option>{categories.map(cat => <option key={cat.id} value={cat.id}>{cat.name}</option>)}</select>
                    </div>
                )}
              </div>
               <div className="mt-6">
                <div className="flex justify-between items-center mb-3"><h3 className="text-xl font-bold text-slate-800 dark:text-slate-200">Журнал записей</h3><button onClick={addJournalEntry} className="flex items-center space-x-2 text-sm px-3 py-2 rounded-md bg-cyan-600 hover:bg-cyan-500 text-white font-semibold transition-colors"><PlusIcon className="w-4 h-4" /><span>Добавить запись</span></button></div>
                 <div className="space-y-4">
                    {journal.length > 0 ? journal.map(entry => (
                        <div key={entry.id} className="bg-white dark:bg-slate-800 rounded-lg p-4 border border-slate-200 dark:border-slate-700">
                            <div className="flex justify-between items-center mb-2"><p className="text-sm font-semibold text-slate-600 dark:text-slate-400">{new Date(entry.createdAt).toLocaleString('ru')}</p><button onClick={() => deleteJournalEntry(entry.id)} className="text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-300 p-1"><TrashIcon className="w-4 h-4" /></button></div>
                            <textarea value={entry.content} onChange={(e) => updateJournalEntry(entry.id, e.target.value)} placeholder="Комментарий..." className="w-full bg-slate-100 dark:bg-slate-700 text-slate-700 dark:text-slate-300 placeholder-slate-400 dark:placeholder-slate-500 rounded-md p-2 focus:outline-none focus:ring-2 focus:ring-cyan-500 resize-y text-sm" rows={2}/>
                        </div>)) 
                        : (<div className="text-center py-6 bg-slate-50 dark:bg-slate-800 rounded-lg border border-dashed border-slate-300 dark:border-slate-700"><p className="text-slate-500 dark:text-slate-400">В журнале пока нет записей.</p></div>)}
                </div>
               </div>
               <Modal title="Применить шаблон" isOpen={isTemplateSelectorOpen} onClose={() => setTemplateSelectorOpen(false)}>
                    <div className="space-y-2 max-h-80 overflow-y-auto">
                        {templates.length > 0 ? templates.map(template => (<div key={template.id} onClick={() => handleApplyTemplate(template)} className="p-3 rounded-md bg-slate-100 dark:bg-slate-700 hover:bg-cyan-100 dark:hover:bg-cyan-900/50 cursor-pointer transition-colors"><h4 className="font-semibold text-slate-800 dark:text-slate-200">{template.title}</h4><p className="text-sm text-slate-500 dark:text-slate-400 line-clamp-2">{template.content}</p></div>)) 
                        : (<p className="text-slate-500 dark:text-slate-400 text-center py-4">Шаблонов пока нет.</p>)}
                    </div>
               </Modal>
               <ReminderModal isOpen={isReminderModalOpen} onClose={() => setReminderModalOpen(false)} onSave={setReminder} initialReminder={reminder} showToast={showToast}/>
          </div>
        );
      };

      const ReminderModal = ({ isOpen, onClose, onSave, initialReminder, showToast }) => {
          const [type, setType] = useState('daily');
          const [startDate, setStartDate] = useState('');
          const [endDate, setEndDate] = useState('');
          const [times, setTimes] = useState(['09:00']);
          const [daysOfWeek, setDaysOfWeek] = useState([]);

          useEffect(() => {
              if (initialReminder) {
                  setType(initialReminder.type);
                  setStartDate(new Date(initialReminder.startDate).toISOString().split('T')[0]);
                  setEndDate(initialReminder.endDate ? new Date(initialReminder.endDate).toISOString().split('T')[0] : '');
                  setTimes(initialReminder.times.length > 0 ? initialReminder.times : ['09:00']);
                  setDaysOfWeek(initialReminder.daysOfWeek || []);
              } else {
                  setType('daily');
                  setStartDate(new Date().toISOString().split('T')[0]);
                  setEndDate('');
                  setTimes(['09:00']);
                  setDaysOfWeek([]);
              }
          }, [initialReminder, isOpen]);

          const handleAddTime = () => {
              if (times.length < 5) setTimes([...times, '12:00']);
              else showToast('Можно добавить не более 5 временных отметок.', 'info');
          };
          const handleRemoveTime = (index) => {
              if (times.length > 1) setTimes(times.filter((_, i) => i !== index));
              else showToast('Должна быть хотя бы одна временная отметка.', 'error');
          };
          const handleTimeChange = (index, value) => setTimes(times.map((t, i) => i === index ? value : t));
          const handleDayToggle = (day) => setDaysOfWeek(prev => prev.includes(day) ? prev.filter(d => d !== day) : [...prev, day]);
          const handleSave = () => {
              if (!startDate || times.some(t => !t) || (type === 'weekly' && daysOfWeek.length === 0)) {
                  showToast('Пожалуйста, заполните все необходимые поля.', 'error'); return;
              }
              const startDateTime = new Date(startDate).setHours(0,0,0,0);
              let endDateTime = endDate ? new Date(endDate).setHours(23,59,59,999) : null;
              if(endDateTime && endDateTime < startDateTime) {
                  showToast('Дата окончания не может быть раньше даты начала.', 'error'); return;
              }
              onSave({ type, startDate: startDateTime, endDate: endDateTime, times: times.filter(t => t), daysOfWeek: type === 'weekly' ? daysOfWeek.sort() : undefined });
              onClose(); showToast('Напоминание сохранено!', 'success');
          };
          const handleRemoveReminder = () => { onSave(null); onClose(); showToast('Напоминание удалено.', 'info'); };
          const weekDays = ['Вс', 'Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб'];
          return (
              <Modal title="Настроить напоминание" isOpen={isOpen} onClose={onClose}>
                  <div className="space-y-4">
                      <div><label className="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-1">Тип повторения</label><select value={type} onChange={e => setType(e.target.value)} className="w-full bg-slate-100 dark:bg-slate-700 text-slate-800 dark:text-white rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-cyan-500"><option value="single">Один раз</option><option value="daily">Ежедневно</option><option value="weekly">Еженедельно</option><option value="monthly">Ежемесячно</option></select></div>
                      <div className="flex space-x-4"><div className="flex-1"><label className="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-1">{type === 'single' ? 'Дата' : 'Дата начала'}</label><input type="date" value={startDate} onChange={e => setStartDate(e.target.value)} className="w-full bg-slate-100 dark:bg-slate-700 text-slate-800 dark:text-white rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-cyan-500" /></div>{type !== 'single' && (<div className="flex-1"><label className="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-1">Дата окончания (необязательно)</label><input type="date" value={endDate} onChange={e => setEndDate(e.target.value)} className="w-full bg-slate-100 dark:bg-slate-700 text-slate-800 dark:text-white rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-cyan-500" /></div>)}</div>
                      {type === 'weekly' && (<div><label className="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-2">Дни недели</label><div className="flex justify-between space-x-1">{weekDays.map((day, index) => (<button key={day} onClick={() => handleDayToggle(index)} className={`w-10 h-10 rounded-full text-sm font-semibold transition-colors ${daysOfWeek.includes(index) ? 'bg-cyan-600 text-white' : 'bg-slate-200 dark:bg-slate-700 text-slate-700 dark:text-slate-300 hover:bg-slate-300 dark:hover:bg-slate-600'}`}>{day}</button>))}</div></div>)}
                      <div><label className="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-1">Время</label><div className="space-y-2">{times.map((time, index) => (<div key={index} className="flex items-center space-x-2"><input type="time" value={time} onChange={e => handleTimeChange(index, e.target.value)} className="w-full bg-slate-100 dark:bg-slate-700 text-slate-800 dark:text-white rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-cyan-500" /><button onClick={() => handleRemoveTime(index)} className="p-2 text-red-500 hover:text-red-600 dark:text-red-400 dark:hover:text-red-300 transition-colors"><XMarkIcon className="w-5 h-5" /></button></div>))}<button onClick={handleAddTime} className="mt-2 flex items-center space-x-2 text-sm text-cyan-600 dark:text-cyan-400 font-semibold hover:text-cyan-700 dark:hover:text-cyan-300"><PlusIcon className="w-4 h-4" /><span>Добавить время</span></button></div></div>
                      <div className="flex justify-between items-center pt-4">
                        <div>
                          {initialReminder && (<button onClick={handleRemoveReminder} className="px-4 py-2 rounded-md bg-red-100 hover:bg-red-200 dark:bg-red-900/50 dark:hover:bg-red-900 text-red-700 dark:text-red-300 font-semibold transition-colors text-sm">Удалить напоминание</button>)}
                        </div>
                        <div className="flex space-x-2">
                          <button onClick={onClose} className="px-4 py-2 rounded-md bg-slate-200 hover:bg-slate-300 dark:bg-slate-600 dark:hover:bg-slate-500 text-slate-800 dark:text-white font-semibold transition-colors">Отмена</button>
                          <button onClick={handleSave} className="px-4 py-2 rounded-md bg-cyan-600 hover:bg-cyan-500 text-white font-semibold transition-colors">Сохранить</button>
                        </div>
                      </div>
                    </div>
              </Modal>
          );
      };
      
      const ColorPicker = ({selectedColor, onSelectColor}) => {
          const colors = ['red', 'yellow', 'green', 'blue', 'purple'];
          return (
              <div className="flex items-center space-x-2 p-1 bg-slate-200 dark:bg-slate-700 rounded-full">
                  <button onClick={() => onSelectColor(null)} className={`w-6 h-6 rounded-full flex items-center justify-center transition-all ${!selectedColor ? 'ring-2 ring-cyan-500' : ''}`}><div className="w-5 h-5 rounded-full bg-slate-400 dark:bg-slate-500 border-2 border-white dark:border-slate-700" style={{backgroundImage: `linear-gradient(to top right, #ef4444 49%, transparent 50%), linear-gradient(to top left, #22c55e 49%, transparent 50%)`}}></div></button>
                  {colors.map(color => (<button key={color} onClick={() => onSelectColor(color)} className={`w-6 h-6 rounded-full bg-${color}-500 transition-all ${selectedColor === color ? 'ring-2 ring-cyan-500' : ''}`} aria-label={`Select ${color} color`}/>))}
              </div>
          );
      };

      const LockScreen = ({ pinHash, onUnlock, hashFn }) => {
          const [pin, setPin] = useState('');
          const [error, setError] = useState('');
          const [isChecking, setIsChecking] = useState(false);

          const handlePinChange = (e) => {
              const newPin = e.target.value.replace(/\D/g, '');
              setPin(newPin);
              if (error) setError('');
          };
          
          const handleSubmit = async (e) => {
              e.preventDefault();
              if (pin.length < 4 || isChecking) return;
              setIsChecking(true); setError('');
              const currentHash = await hashFn(pin);
              if (currentHash === pinHash) onUnlock();
              else { setError('Неверный PIN-код'); setPin(''); }
              setIsChecking(false);
          };

          return (
              <div className="fixed inset-0 bg-slate-100 dark:bg-slate-900 flex items-center justify-center z-50">
                  <div className="w-full max-w-xs p-8 bg-white dark:bg-slate-800 rounded-lg shadow-2xl text-center">
                      <LockClosedIcon className="w-12 h-12 mx-auto text-cyan-500 dark:text-cyan-400 mb-4"/><h2 className="text-2xl font-bold mb-2 text-slate-800 dark:text-slate-200">Введите PIN-код</h2><p className="text-slate-500 dark:text-slate-400 mb-6">Это приложение защищено.</p>
                      <form onSubmit={handleSubmit}>
                          <input type="password" maxLength={4} value={pin} onChange={handlePinChange} className={`w-40 text-center tracking-[1em] text-3xl font-mono bg-slate-100 dark:bg-slate-700 rounded-md p-2 focus:outline-none focus:ring-2 focus:ring-cyan-500 ${error ? 'ring-2 ring-red-500' : ''}`} autoFocus />
                          {error && <p className="text-red-500 text-sm mt-2">{error}</p>}
                          <button type="submit" disabled={pin.length < 4 || isChecking} className="w-full mt-6 px-4 py-2 rounded-md bg-cyan-600 hover:bg-cyan-500 text-white font-semibold transition-colors disabled:bg-cyan-400 dark:disabled:bg-cyan-800 disabled:cursor-not-allowed">{isChecking ? 'Проверка...' : 'Разблокировать'}</button>
                      </form>
                  </div>
              </div>
          );
      };

      const SettingsModal = ({ isOpen, onClose, pinHash, setPinHash, hashFn, showToast, theme, setTheme, onEnablePushNotifications }) => {
          const [currentPin, setCurrentPin] = useState('');
          const [newPin, setNewPin] = useState('');
          const [confirmPin, setConfirmPin] = useState('');
          const [notificationPermission, setNotificationPermission] = useState('Notification' in window ? Notification.permission : 'unsupported');
          
          const resetForm = () => { setCurrentPin(''); setNewPin(''); setConfirmPin(''); };

          const handleSetPin = async () => {
              if (newPin.length < 4 || newPin !== confirmPin) { showToast(newPin.length < 4 ? 'PIN-код должен содержать 4 цифры' : 'PIN-коды не совпадают', 'error'); return; }
              const newHash = await hashFn(newPin); setPinHash(newHash); showToast('PIN-код успешно установлен!', 'success'); resetForm();
          };
          const handleChangePin = async () => {
              const currentHash = await hashFn(currentPin);
              if (currentHash !== pinHash) { showToast('Текущий PIN-код неверный', 'error'); return; }
              await handleSetPin();
          };
          const handleRemovePin = async () => {
              const currentHash = await hashFn(currentPin);
              if (currentHash !== pinHash) { showToast('Текущий PIN-код неверный', 'error'); return; }
              setPinHash(null); showToast('PIN-код удален', 'info'); resetForm();
          };
          const handleModalClose = () => { resetForm(); onClose(); };

          return (
              <Modal title="Настройки" isOpen={isOpen} onClose={handleModalClose}>
                  <div className="space-y-6">
                       <div>
                          <h3 className="text-lg font-semibold mb-2 text-slate-800 dark:text-slate-200">Тема оформления</h3>
                          <div className="flex space-x-2 rounded-lg bg-slate-200 dark:bg-slate-700 p-1">
                              <button onClick={() => setTheme('light')} className={`w-full flex items-center justify-center space-x-2 p-2 rounded-md text-sm font-semibold transition-colors ${theme === 'light' ? 'bg-white text-cyan-600 shadow-sm' : 'text-slate-600 dark:text-slate-300'}`}><SunIcon className="w-5 h-5" /><span>Светлая</span></button>
                               <button onClick={() => setTheme('dark')} className={`w-full flex items-center justify-center space-x-2 p-2 rounded-md text-sm font-semibold transition-colors ${theme === 'dark' ? 'bg-slate-800 text-cyan-400 shadow-sm' : 'text-slate-600 dark:text-slate-300'}`}><MoonIcon className="w-5 h-5" /><span>Темная</span></button>
                          </div>
                      </div>
                      <div>
                          <h3 className="text-lg font-semibold mb-2 text-slate-800 dark:text-slate-200">Push-уведомления</h3>
                          <div className="p-4 rounded-lg bg-slate-100 dark:bg-slate-700/50">
                               <p className="text-sm text-slate-600 dark:text-slate-300 mb-3">Включите, чтобы получать напоминания, даже когда приложение закрыто.</p>
                               <button onClick={onEnablePushNotifications} className="w-full px-4 py-2 rounded-md bg-cyan-600 hover:bg-cyan-500 text-white font-semibold transition-colors text-sm">Включить Push-уведомления</button>
                          </div>
                      </div>
                      <div>
                          <h3 className="text-lg font-semibold mb-2 text-slate-800 dark:text-slate-200">Безопасность</h3>
                          <div className="p-4 rounded-lg bg-slate-100 dark:bg-slate-700/50 space-y-3">
                              {pinHash ? (
                                  <>
                                      <input type="password" placeholder="Текущий PIN (4 цифры)" value={currentPin} onChange={e => setCurrentPin(e.target.value.replace(/\D/g, ''))} maxLength={4} className="w-full bg-slate-200 dark:bg-slate-600 text-slate-900 dark:text-white rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-cyan-500" />
                                      <input type="password" placeholder="Новый PIN (4 цифры)" value={newPin} onChange={e => setNewPin(e.target.value.replace(/\D/g, ''))} maxLength={4} className="w-full bg-slate-200 dark:bg-slate-600 text-slate-900 dark:text-white rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-cyan-500" />
                                      <input type="password" placeholder="Подтвердите новый PIN" value={confirmPin} onChange={e => setConfirmPin(e.target.value.replace(/\D/g, ''))} maxLength={4} className="w-full bg-slate-200 dark:bg-slate-600 text-slate-900 dark:text-white rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-cyan-500" />
                                      <div className="flex space-x-2 pt-2"><button onClick={handleChangePin} className="flex-1 px-4 py-2 rounded-md bg-cyan-600 hover:bg-cyan-500 text-white font-semibold transition-colors text-sm">Изменить PIN</button><button onClick={handleRemovePin} className="flex-1 px-4 py-2 rounded-md bg-red-600 hover:bg-red-500 text-white font-semibold transition-colors text-sm">Удалить PIN</button></div>
                                  </>
                              ) : (
                                  <>
                                       <input type="password" placeholder="Новый PIN (4 цифры)" value={newPin} onChange={e => setNewPin(e.target.value.replace(/\D/g, ''))} maxLength={4} className="w-full bg-slate-200 dark:bg-slate-600 text-slate-900 dark:text-white rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-cyan-500" />
                                      <input type="password" placeholder="Подтвердите новый PIN" value={confirmPin} onChange={e => setConfirmPin(e.target.value.replace(/\D/g, ''))} maxLength={4} className="w-full bg-slate-200 dark:bg-slate-600 text-slate-900 dark:text-white rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-cyan-500" />
                                      <button onClick={handleSetPin} className="w-full mt-2 px-4 py-2 rounded-md bg-cyan-600 hover:bg-cyan-500 text-white font-semibold transition-colors">Установить PIN</button>
                                  </>
                              )}
                          </div>
                      </div>
                  </div>
              </Modal>
          );
      };

      const TemplateManagerModal = ({ isOpen, onClose, templates, onSave, onDelete }) => {
          const [editingTemplate, setEditingTemplate] = useState(null);
          const handleSave = () => {
              if (editingTemplate && onSave(editingTemplate)) setEditingTemplate(null);
          };
          if (!isOpen) return null;
          if (editingTemplate) {
              return (
                   <Modal title={ editingTemplate.id ? "Редактировать шаблон" : "Новый шаблон" } isOpen={isOpen} onClose={() => setEditingTemplate(null)}>
                      <div className="space-y-4">
                          <input type="text" placeholder="Название шаблона" value={editingTemplate.title} onChange={e => setEditingTemplate({...editingTemplate, title: e.target.value})} className="w-full bg-slate-100 dark:bg-slate-700 text-slate-900 dark:text-white placeholder-slate-500 dark:placeholder-slate-400 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-cyan-500"/>
                          <textarea placeholder="Содержимое шаблона..." value={editingTemplate.content} onChange={e => setEditingTemplate({...editingTemplate, content: e.target.value})} className="w-full h-40 bg-slate-100 dark:bg-slate-700 text-slate-700 dark:text-slate-300 placeholder-slate-400 dark:placeholder-slate-500 rounded-md px-3 py-2 focus:outline-none resize-y focus:ring-2 focus:ring-cyan-500"/>
                          <div className="flex justify-end space-x-2"><button onClick={() => setEditingTemplate(null)} className="px-4 py-2 rounded-md bg-slate-200 hover:bg-slate-300 dark:bg-slate-600 dark:hover:bg-slate-500 text-slate-800 dark:text-white font-semibold transition-colors">Отмена</button><button onClick={handleSave} className="px-4 py-2 rounded-md bg-cyan-600 hover:bg-cyan-500 text-white font-semibold transition-colors">Сохранить</button></div>
                      </div>
                  </Modal>
              )
          }
          return (
              <Modal title="Управление шаблонами" isOpen={isOpen} onClose={onClose}>
                  <div className="space-y-3">
                      <button onClick={() => setEditingTemplate({title: '', content: ''})} className="w-full flex items-center justify-center space-x-2 mb-3 px-4 py-2 rounded-md bg-cyan-600 hover:bg-cyan-500 text-white font-semibold transition-colors"><PlusIcon className="w-5 h-5" /><span>Создать новый шаблон</span></button>
                      <div className="space-y-2 max-h-80 overflow-y-auto">
                          {templates.length > 0 ? templates.map(template => (
                              <div key={template.id} className="p-3 rounded-md bg-slate-100 dark:bg-slate-700">
                                  <div className="flex justify-between items-start">
                                      <div><h4 className="font-semibold text-slate-800 dark:text-slate-200">{template.title}</h4><p className="text-sm text-slate-500 dark:text-slate-400 line-clamp-2">{template.content}</p></div>
                                      <div className="flex space-x-1 flex-shrink-0 ml-2"><button onClick={() => setEditingTemplate(template)} className="p-1 text-slate-500 dark:text-slate-400 hover:text-cyan-500 dark:hover:text-cyan-400 transition-colors"><PencilIcon className="w-5 h-5"/></button><button onClick={() => onDelete(template.id)} className="p-1 text-red-500 dark:text-red-400 hover:text-red-600 dark:hover:text-red-300 transition-colors"><TrashIcon className="w-5 h-5"/></button></div>
                                  </div>
                              </div>
                          )) : (<p className="text-slate-500 dark:text-slate-400 text-center py-4">Шаблонов пока нет.</p>)}
                      </div>
                  </div>
              </Modal>
          );
      };

      const App = () => {
        const [notes, setNotes] = useLocalStorage('notes', []);
        const [categories, setCategories] = useLocalStorage('categories', []);
        const [templates, setTemplates] = useLocalStorage('templates', []);
        const [fcmToken, setFcmToken] = useLocalStorage('fcmToken', null);
        const [activeToast, setActiveToast] = useState(null);
        const [view, setView] = useState('LIST');
        const [currentNote, setCurrentNote] = useState(null);
        const [isCategoryModalOpen, setCategoryModalOpen] = useState(false);
        const [newCategoryName, setNewCategoryName] = useState('');
        const [editingCategoryId, setEditingCategoryId] = useState(null);
        const [editedCategoryName, setEditedCategoryName] = useState('');
        const [activeFilter, setActiveFilter] = useState('ALL');
        const [searchQuery, setSearchQuery] = useState('');
        const [sortOrder, setSortOrder] = useState('updatedAt_desc');
        const [noteToTrash, setNoteToTrash] = useState(null);
        const [noteToDelete, setNoteToDelete] = useState(null);
        const [isDeleteAllModalOpen, setDeleteAllModalOpen] = useState(false);
        const [isImportModalOpen, setImportModalOpen] = useState(false);
        const importFileInputRef = useRef(null);
        const [dataToImport, setDataToImport] = useState(null);
        const [isSelectionMode, setSelectionMode] = useState(false);
        const [selectedNoteIds, setSelectedNoteIds] = useState([]);
        const [isDeleteSelectedModalOpen, setDeleteSelectedModalOpen] = useState(false);
        const [isClearTrashModalOpen, setClearTrashModalOpen] = useState(false);
        const [pinHash, setPinHash] = useLocalStorage('smart-notepad-pin', null);
        const [isUnlocked, setIsUnlocked] = useState(!pinHash);
        const [isSettingsModalOpen, setSettingsModalOpen] = useState(false);
        const [isTemplateModalOpen, setTemplateModalOpen] = useState(false);
        const osTheme = window.matchMedia?.('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
        const [theme, setTheme] = useLocalStorage('theme', osTheme);
        
        useEffect(() => {
          const root = window.document.documentElement;
          if (theme === 'dark') {
            root.classList.add('dark');
          } else {
            root.classList.remove('dark');
          }
        }, [theme]);

        useEffect(() => {
          const isMigrated = localStorage.getItem('smart-notepad-reminder-migrated-v2');
          if (isMigrated) return;

          const notesToMigrate = notes.some(n => n.reminderAt);

          if (notesToMigrate) {
              const migratedNotes = notes.map(note => {
                  const oldNote = note;
                  let newNotePart = {};

                  if (oldNote.reminderAt) {
                      const reminderDate = new Date(oldNote.reminderAt);
                      const newReminder = {
                          type: 'single',
                          startDate: reminderDate.getTime(),
                          times: [`${String(reminderDate.getHours()).padStart(2, '0')}:${String(reminderDate.getMinutes()).padStart(2, '0')}`],
                          nextDueDate: reminderDate.getTime(),
                          endDate: null,
                      };
                      newNotePart.reminder = newReminder;
                  } else {
                      newNotePart.reminder = note.reminder || null;
                  }

                  if (!note.journal) {
                      newNotePart.journal = [];
                  }
                  
                  const { reminderAt, ...restOfNote } = oldNote;

                  return { ...restOfNote, ...newNotePart };
              });
              setNotes(migratedNotes);
              showToast('Напоминания обновлены до нового формата!', 'info');
          }
          localStorage.setItem('smart-notepad-reminder-migrated-v2', 'true');
        }, []);

        const showToast = useCallback((message, type = 'info') => {
          setActiveToast({ id: Date.now(), message, type });
        }, []);
        
        useEffect(() => {
          const handleUrlImport = () => {
              try {
                  const hash = window.location.hash;
                  if (hash.startsWith('#/import-note/')) {
                      const encodedData = hash.substring('#/import-note/'.length);
                      const decodedJson = atob(decodeURIComponent(encodedData));
                      const noteData = JSON.parse(decodedJson);

                      if (noteData.title && typeof noteData.content !== 'undefined') {
                           const now = Date.now();
                           const newNote = {
                              id: now.toString(),
                              title: noteData.title,
                              content: noteData.content,
                              color: noteData.color || null,
                              createdAt: now,
                              updatedAt: now,
                              isFavorite: false,
                              isPinned: false,
                              categoryId: null,
                              reminder: null,
                              journal: [],
                              deletedAt: null,
                           };
                           setNotes(prevNotes => [newNote, ...prevNotes]);
                           showToast('Заметка успешно импортирована!', 'success');
                           
                           window.history.replaceState(null, '', window.location.pathname + window.location.search);
                      }
                  }
              } catch (e) {
                  console.error("Failed to import note from URL", e);
                  showToast('Не удалось импортировать заметку по ссылке.', 'error');
              }
          };
          handleUrlImport();
        }, [setNotes, showToast]);
        
        const hashPin = async (pin) => {
            const encoder = new TextEncoder();
            const data = encoder.encode(pin);
            const hashBuffer = await crypto.subtle.digest('SHA-2-256', data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        };

        const handleEnablePushNotifications = async () => {
            if (!('firebase' in window) || !firebase.messaging.isSupported()) {
                showToast('Push-уведомления не поддерживаются в этом браузере.', 'error');
                return;
            }

            try {
                const messaging = firebase.messaging();
                const permission = await Notification.requestPermission();

                if (permission === 'granted') {
                    showToast('Разрешение на уведомления получено.', 'info');
                    const token = await messaging.getToken({ vapidKey: 'BPE0Lfv2y7IakhcYrbVzkIwDCPiPh-HLe2KJAUD86VBED_9rysj-jFG-c1IzUXJmZLgTl0-IZC0zX9UglvEJU4Q' });
                    
                    if (token) {
                        console.log('FCM Token:', token);
                        setFcmToken(token); // Сохраняем токен для последующего использования
                        showToast('Push-уведомления успешно включены!', 'success');
                    } else {
                        setFcmToken(null);
                        showToast('Не удалось получить токен для Push-уведомлений. Попробуйте обновить страницу.', 'error');
                    }
                } else {
                    setFcmToken(null);
                    showToast('Вы не разрешили показ уведомлений.', 'error');
                }
            } catch (err) {
                console.error('An error occurred while enabling push notifications. ', err);
                setFcmToken(null);
                showToast('Ошибка при включении Push-уведомлений. Убедитесь, что конфигурация Firebase верна.', 'error');
            }
        };

        const handleSaveNote = (noteData) => {
          const now = Date.now();
          
          let processedReminder = noteData.reminder;
          let oldReminder = null;
          
          if (currentNote) {
            oldReminder = notes.find(n => n.id === currentNote.id)?.reminder || null;
          }

          if (processedReminder) {
              const nextDueDate = calculateNextDueDate(processedReminder, Date.now());
              processedReminder = { ...processedReminder, nextDueDate };
          }

          const noteToSave = currentNote 
            ? { ...notes.find(n => n.id === currentNote.id), ...noteData, reminder: processedReminder, updatedAt: now }
            : {
                id: now.toString(),
                ...noteData,
                reminder: processedReminder,
                createdAt: now,
                updatedAt: now,
                isPinned: false,
                deletedAt: null,
              };

          // --- Логика отправки на сервер (Cloud Function) ---
          if (fcmToken) {
            // URL вашей Cloud Function. Он появится в терминале после развертывания.
            // Структура обычно: https://<region>-<project-id>.cloudfunctions.net/<functionName>
            const CLOUD_FUNCTION_URL = 'https://us-central1-smart-notepad-1de7f.cloudfunctions.net/setReminder';
            
            fetch(CLOUD_FUNCTION_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    token: fcmToken,
                    noteId: noteToSave.id,
                    noteTitle: noteToSave.title,
                    noteContent: noteToSave.content.substring(0, 100), // Отправляем превью контента
                    newReminder: processedReminder, // Отправляем новое напоминание
                    oldReminder: oldReminder, // Отправляем старое, чтобы сервер мог отменить предыдущие задачи
                })
            }).then(res => {
                if (!res.ok) throw new Error('Server responded with an error');
                console.log('Reminder scheduled successfully on server.');
            }).catch(err => {
                console.error('Failed to schedule reminder on server:', err);
                showToast('Не удалось запланировать напоминание на сервере.', 'error');
            });

          } else if (processedReminder) {
             showToast('Включите Push-уведомления в настройках, чтобы напоминания работали.', 'info');
          }

          if (currentNote) {
            setNotes(notes.map(n => n.id === currentNote.id ? noteToSave : n));
            showToast('Заметка обновлена', 'success');
          } else {
            setNotes([noteToSave, ...notes]);
            showToast('Заметка создана', 'success');
          }
          setView('LIST');
          setCurrentNote(null);
        };
        
        const handleMoveToTrash = (id) => {
          setNoteToTrash(id);
        };

        const confirmMoveToTrash = () => {
          if (!noteToTrash) return;
          setNotes(notes.map(n => n.id === noteToTrash ? { ...n, deletedAt: Date.now(), isPinned: false } : n));
          showToast('Заметка перемещена в корзину', 'info');
          setNoteToTrash(null);
        };
        
        const handleRestoreNote = (id) => {
          setNotes(notes.map(n => n.id === id ? { ...n, deletedAt: null } : n));
          showToast('Заметка восстановлена', 'success');
        };
        
        const handleDeletePermanently = (id) => {
          setNoteToDelete(id);
        };
        
        const confirmDeletePermanently = () => {
          if (!noteToDelete) return;
          setNotes(notes.filter(n => n.id !== noteToDelete));
          showToast('Заметка удалена навсегда', 'error');
          setNoteToDelete(null);
        };

        const handleEmptyTrash = () => {
          setNotes(notes.filter(n => !n.deletedAt));
          showToast('Корзина очищена', 'error');
          setClearTrashModalOpen(false);
        };

        const handleToggleFavorite = (id) => {
          setNotes(notes.map(n => {
            if (n.id === id) {
              const isNowFavorite = !n.isFavorite;
              return { ...n, isFavorite: isNowFavorite, categoryId: isNowFavorite ? n.categoryId : null };
            }
            return n;
          }));
        };
        
        const handleTogglePin = (id) => {
          setNotes(notes.map(n => n.id === id ? { ...n, isPinned: !n.isPinned } : n));
        };
        
        const handleToggleChecklistItem = (noteId, itemIndex) => {
              setNotes(prevNotes => {
                  const noteToUpdate = prevNotes.find(n => n.id === noteId);
                  if (!noteToUpdate) return prevNotes;

                  const lines = noteToUpdate.content.split('\n');
                  let currentChecklistItem = -1;
                  const newLines = lines.map(line => {
                      if (line.trim().startsWith('- [ ]') || line.trim().startsWith('- [x]')) {
                          currentChecklistItem++;
                          if (currentChecklistItem === itemIndex) {
                              return line.includes('[ ]') ? line.replace('[ ]', '[x]') : line.replace('[x]', '[ ]');
                          }
                      }
                      return line;
                  });

                  return prevNotes.map(n => 
                      n.id === noteId 
                          ? { ...n, content: newLines.join('\n'), updatedAt: Date.now() } 
                          : n
                  );
              });
          };

        const handleChangeCategory = (noteId, categoryId) => {
            setNotes(notes.map(n => n.id === noteId ? { ...n, categoryId: categoryId } : n));
        };

        const handleCreateCategory = () => {
          if (newCategoryName.trim() === '') {
            showToast('Название категории не может быть пустым', 'error');
            return;
          }
          const newCategory = { id: Date.now().toString(), name: newCategoryName.trim() };
          setCategories([...categories, newCategory]);
          setNewCategoryName('');
          showToast('Категория создана', 'success');
        };

        const handleDeleteCategory = (id) => {
          setNotes(notes.map(n => n.categoryId === id ? { ...n, categoryId: null } : n));
          setCategories(categories.filter(c => c.id !== id));
          showToast('Категория удалена', 'error');
        };

        const startEditCategory = (category) => {
          setEditingCategoryId(category.id);
          setEditedCategoryName(category.name);
        };

        const cancelEditCategory = () => {
            setEditingCategoryId(null);
            setEditedCategoryName('');
        };

        const handleUpdateCategory = () => {
            if (!editingCategoryId || editedCategoryName.trim() === '') {
                showToast('Название категории не может быть пустым', 'error');
                return;
            }
            setCategories(categories.map(c => c.id === editingCategoryId ? { ...c, name: editedCategoryName.trim() } : c));
            showToast('Категория обновлена', 'success');
            cancelEditCategory();
        };

        const handleSaveTemplate = (templateData) => {
          if (templateData.title.trim() === '') {
              showToast('Название шаблона не может быть пустым', 'error');
              return false;
          }
          if (templateData.id) {
              setTemplates(templates.map(t => t.id === templateData.id ? { ...t, title: templateData.title, content: templateData.content } : t));
              showToast('Шаблон обновлен', 'success');
          } else {
              const newTemplate = {
                  id: Date.now().toString(),
                  title: templateData.title.trim(),
                  content: templateData.content
              };
              setTemplates([...templates, newTemplate]);
              showToast('Шаблон создан', 'success');
          }
          return true;
        };

        const handleDeleteTemplate = (id) => {
            setTemplates(templates.filter(t => t.id !== id));
            showToast('Шаблон удален', 'error');
        };

        const openEditor = (note) => {
          setCurrentNote(note);
          setView('EDITOR');
        };
        
        const navigateTo = (targetView) => {
          setView(targetView);
          setSelectionMode(false);
          setSelectedNoteIds([]);
        };

        const handleExportData = () => {
          try {
            const data = JSON.stringify({ notes, categories, templates, theme, fcmToken }, null, 2);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `smart-notepad-backup-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showToast('Данные успешно экспортированы!', 'success');
          } catch (error) {
            console.error('Export failed:', error);
            showToast('Ошибка при экспорте данных.', 'error');
          }
        };

        const handleImportClick = () => {
          importFileInputRef.current?.click();
        };

        const handleImportFileChange = (event) => {
          const file = event.target.files?.[0];
          if (!file) return;

          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const text = e.target?.result;
              if (typeof text !== 'string') throw new Error('File is not a text file');
              const parsedData = JSON.parse(text);

              if (Array.isArray(parsedData.notes) && Array.isArray(parsedData.categories)) {
                const notesWithDefaults = parsedData.notes.map((n) => ({
                    id: n.id || Date.now().toString(),
                    title: n.title || '',
                    content: n.content || '',
                    createdAt: n.createdAt || Date.now(),
                    updatedAt: n.updatedAt || Date.now(),
                    isFavorite: n.isFavorite ?? false,
                    categoryId: n.categoryId ?? null,
                    isPinned: n.isPinned ?? false,
                    color: n.color ?? null,
                    reminder: n.reminder ?? null,
                    journal: n.journal ?? [],
                    deletedAt: n.deletedAt ?? null,
                }));
                const templatesWithDefaults = (parsedData.templates || []).map((t) => ({
                    id: t.id || Date.now().toString(),
                    title: t.title || 'Без названия',
                    content: t.content || '',
                }));
                
                const themeFromImport = parsedData.theme === 'light' ? 'light' : 'dark';
                const fcmTokenFromImport = parsedData.fcmToken || null;
                setDataToImport({ notes: notesWithDefaults, categories: parsedData.categories, templates: templatesWithDefaults, theme: themeFromImport, fcmToken: fcmTokenFromImport });
                setImportModalOpen(true);
              } else {
                throw new Error('Invalid file structure');
              }
            } catch (error) {
              console.error('Import failed:', error);
              showToast('Ошибка: Неверный формат файла.', 'error');
            } finally {
              if (importFileInputRef.current) {
                importFileInputRef.current.value = '';
              }
            }
          };
          reader.readAsText(file);
        };

        const confirmImportData = () => {
          if (dataToImport) {
              setNotes(dataToImport.notes);
              setCategories(dataToImport.categories);
              setTemplates(dataToImport.templates);
              setTheme(dataToImport.theme);
              setFcmToken(dataToImport.fcmToken);
              showToast('Данные успешно импортированы!', 'success');
          }
          setImportModalOpen(false);
          setDataToImport(null);
        };
        
        const handleToggleSelectionMode = () => {
          setSelectionMode(prev => !prev);
          setSelectedNoteIds([]);
        };

        const handleSelectNote = (id) => {
          if (!isSelectionMode) return;
          setSelectedNoteIds(prev =>
            prev.includes(id)
              ? prev.filter(noteId => noteId !== id)
              : [...prev, id]
          );
        };

        const confirmDeleteSelected = () => {
          const count = selectedNoteIds.length;
          
          if (view === 'TRASH') {
              setNotes(notes.filter(n => !selectedNoteIds.includes(n.id)));
          } else {
              const now = Date.now();
              setNotes(notes.map(n => selectedNoteIds.includes(n.id) ? {...n, deletedAt: now, isPinned: false} : n));
          }
          
          let message = '';
          const lastDigit = count % 10;
          const lastTwoDigits = count % 100;

          if (lastDigit === 1 && lastTwoDigits !== 11) {
              message = `${count} заметка ${view === 'TRASH' ? 'удалена' : 'перемещена в корзину'}`;
          } else if ([2, 3, 4].includes(lastDigit) && ![12, 13, 14].includes(lastTwoDigits)) {
              message = `${count} заметки ${view === 'TRASH' ? 'удалены' : 'перемещены в корзину'}`;
          } else {
              message = `${count} заметок ${view === 'TRASH' ? 'удалено' : 'перемещено в корзину'}`;
          }

          showToast(message, 'error');
          setDeleteSelectedModalOpen(false);
          setSelectionMode(false);
          setSelectedNoteIds([]);
        };

        const confirmDeleteAllActive = () => {
          const now = Date.now();
          setNotes(notes.map(n => !n.deletedAt ? { ...n, deletedAt: now, isPinned: false } : n));
          showToast('Все заметки перемещены в корзину', 'info');
          setDeleteAllModalOpen(false);
        };

        const activeNotes = useMemo(() => notes.filter(n => !n.deletedAt), [notes]);
        const trashedNotes = useMemo(() => {
          const sorted = notes.filter(n => n.deletedAt);
          sorted.sort((a,b) => (b.deletedAt || 0) - (a.deletedAt || 0));
          return sorted;
        }, [notes]);


        const filteredNotes = useMemo(() => {
          const sortNotes = (notesToSort) => {
            const sorted = [...notesToSort];
            switch (sortOrder) {
              case 'updatedAt_desc': sorted.sort((a, b) => b.updatedAt - a.updatedAt); break;
              case 'updatedAt_asc': sorted.sort((a, b) => a.updatedAt - b.updatedAt); break;
              case 'createdAt_desc': sorted.sort((a, b) => b.createdAt - a.createdAt); break;
              case 'createdAt_asc': sorted.sort((a, b) => a.createdAt - b.createdAt); break;
              case 'title_asc': sorted.sort((a, b) => a.title.localeCompare(b.title)); break;
              case 'title_desc': sorted.sort((a, b) => b.title.localeCompare(a.title)); break;
            }
            return sorted;
          };
          
          let notesToDisplay = activeNotes;
          if (activeFilter === 'FAVORITES') {
            notesToDisplay = activeNotes.filter(n => n.isFavorite);
          }

          if (searchQuery.trim() !== '') {
              notesToDisplay = notesToDisplay.filter(note => 
                  note.title.toLowerCase().includes(searchQuery.toLowerCase()) || 
                  note.content.toLowerCase().includes(searchQuery.toLowerCase())
              );
          }
          
          const pinnedNotes = notesToDisplay.filter(n => n.isPinned);
          const unpinnedNotes = notesToDisplay.filter(n => !n.isPinned);

          return [...sortNotes(pinnedNotes), ...sortNotes(unpinnedNotes)];

        }, [activeNotes, activeFilter, searchQuery, sortOrder]);

        const favoritesByCategory = useMemo(() => {
          if (activeFilter !== 'FAVORITES') return [];
          
          const grouped = [];
          const uncategorized = [];

          const categoryMap = new Map(categories.map(c => [c.id, c]));

          const notesForGrouping = filteredNotes.filter(n => n.isFavorite);

          for (const note of notesForGrouping) {
              if (note.categoryId && categoryMap.has(note.categoryId)) {
                const category = categoryMap.get(note.categoryId);
                let group = grouped.find(g => g.category?.id === category.id);
                if (!group) {
                  group = { category, notes: [] };
                  grouped.push(group);
                }
                group.notes.push(note);
              } else {
                uncategorized.push(note);
              }
          }
          
          grouped.sort((a, b) => a.category.name.localeCompare(b.category.name));

          if (uncategorized.length > 0) {
            grouped.push({ category: null, notes: uncategorized });
          }

          return grouped;
        }, [filteredNotes, categories, activeFilter]);

        if (!isUnlocked) {
            return <LockScreen pinHash={pinHash} onUnlock={() => setIsUnlocked(true)} hashFn={hashPin} />;
        }

        return (
          <div className="min-h-screen bg-white dark:bg-slate-900 font-sans text-slate-900 dark:text-slate-100">
            <div className="container mx-auto max-w-3xl p-4">
              {view === 'LIST' && (
                <ListView
                  notes={filteredNotes}
                  categories={categories}
                  activeFilter={activeFilter}
                  favoritesByCategory={favoritesByCategory}
                  setActiveFilter={setActiveFilter}
                  onEdit={openEditor}
                  onDelete={handleMoveToTrash}
                  onToggleFavorite={handleToggleFavorite}
                  onTogglePin={handleTogglePin}
                  onChangeCategory={handleChangeCategory}
                  onOpenCategoryModal={() => setCategoryModalOpen(true)}
                  onOpenSettingsModal={() => setSettingsModalOpen(true)}
                  onOpenTemplateModal={() => setTemplateModalOpen(true)}
                  searchQuery={searchQuery}
                  onSearchChange={setSearchQuery}
                  sortOrder={sortOrder}
                  onSortChange={setSortOrder}
                  onExport={handleExportData}
                  onImport={handleImportClick}
                  isSelectionMode={isSelectionMode}
                  selectedNoteIds={selectedNoteIds}
                  onToggleSelectionMode={handleToggleSelectionMode}
                  onSelectNote={handleSelectNote}
                  onDeleteAll={() => setDeleteAllModalOpen(true)}
                  onNavigate={navigateTo}
                  trashedCount={trashedNotes.length}
                  onToggleChecklistItem={handleToggleChecklistItem}
                />
              )}
              {view === 'TRASH' && (
                 <TrashView
                   notes={trashedNotes}
                   onRestore={handleRestoreNote}
                   onDelete={handleDeletePermanently}
                   onEmptyTrash={() => setClearTrashModalOpen(true)}
                   onNavigate={navigateTo}
                   isSelectionMode={isSelectionMode}
                   selectedNoteIds={selectedNoteIds}
                   onToggleSelectionMode={handleToggleSelectionMode}
                   onSelectNote={handleSelectNote}
                   onDeleteSelected={() => setDeleteSelectedModalOpen(true)}
                 />
              )}
              {view === 'EDITOR' && (
                <NoteEditor
                  note={currentNote}
                  categories={categories}
                  templates={templates}
                  onSave={handleSaveNote}
                  onCancel={() => { navigateTo('LIST'); setCurrentNote(null); }}
                  theme={theme}
                  showToast={showToast}
                />
              )}
              
              <input type="file" ref={importFileInputRef} onChange={handleImportFileChange} className="hidden" accept="application/json" />

              <TemplateManagerModal 
                isOpen={isTemplateModalOpen}
                onClose={() => setTemplateModalOpen(false)}
                templates={templates}
                onSave={handleSaveTemplate}
                onDelete={handleDeleteTemplate}
              />

              <Modal title="Управление категориями" isOpen={isCategoryModalOpen} onClose={() => { setCategoryModalOpen(false); cancelEditCategory(); }}>
                <div className="space-y-4">
                  <div className="flex space-x-2">
                    <input
                      type="text"
                      value={newCategoryName}
                      onChange={(e) => setNewCategoryName(e.target.value)}
                      placeholder="Новая категория..."
                      className="flex-grow bg-slate-100 dark:bg-slate-700 text-slate-900 dark:text-white placeholder-slate-500 dark:placeholder-slate-400 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-cyan-500"
                      onKeyDown={(e) => e.key === 'Enter' && handleCreateCategory()}
                    />
                    <button onClick={handleCreateCategory} className="bg-cyan-500 hover:bg-cyan-600 dark:bg-cyan-600 dark:hover:bg-cyan-500 text-white font-bold p-2 rounded-md transition-colors">
                      <PlusIcon className="w-5 h-5"/>
                    </button>
                  </div>
                  <div className="space-y-2 max-h-60 overflow-y-auto">
                    {categories.length > 0 ? categories.map(cat => (
                      <div key={cat.id} className="flex justify-between items-center bg-slate-100 dark:bg-slate-700 p-2 rounded-md">
                         {editingCategoryId === cat.id ? (
                            <>
                              <input
                                type="text"
                                value={editedCategoryName}
                                onChange={(e) => setEditedCategoryName(e.target.value)}
                                className="flex-grow bg-white dark:bg-slate-600 text-slate-900 dark:text-white rounded-md px-2 py-1 mr-2 focus:outline-none focus:ring-2 focus:ring-cyan-500"
                                autoFocus
                                onKeyDown={(e) => e.key === 'Enter' && handleUpdateCategory()}
                              />
                              <div className="flex space-x-1">
                                <button onClick={handleUpdateCategory} className="text-green-500 hover:text-green-600 dark:text-green-400 dark:hover:text-green-300 p-1">
                                  <CheckIcon className="w-5 h-5"/>
                                </button>
                                <button onClick={cancelEditCategory} className="text-slate-500 dark:text-slate-400 hover:text-slate-900 dark:hover:text-white p-1">
                                  <XMarkIcon className="w-5 h-5"/>
                                </button>
                              </div>
                            </>
                          ) : (
                            <>
                              <span className="truncate pr-2">{cat.name}</span>
                              <div className="flex space-x-1 flex-shrink-0">
                                <button onClick={() => startEditCategory(cat)} className="text-slate-500 dark:text-slate-400 hover:text-cyan-500 dark:hover:text-cyan-400 p-1">
                                  <PencilIcon className="w-5 h-5"/>
                                </button>
                                <button onClick={() => handleDeleteCategory(cat.id)} className="text-red-500 hover:text-red-600 dark:text-red-400 dark:hover:text-red-300 p-1">
                                  <TrashIcon className="w-5 h-5"/>
                                </button>
                              </div>
                            </>
                          )}
                      </div>
                    )) : (
                      <p className="text-slate-500 dark:text-slate-400 text-center">Категорий пока нет.</p>
                    )}
                  </div>
                </div>
              </Modal>
              
               <SettingsModal 
                  isOpen={isSettingsModalOpen} 
                  onClose={() => setSettingsModalOpen(false)}
                  pinHash={pinHash}
                  setPinHash={setPinHash}
                  hashFn={hashPin}
                  showToast={showToast}
                  theme={theme}
                  setTheme={setTheme}
                  onEnablePushNotifications={handleEnablePushNotifications}
              />
              
              <Modal title="Переместить в корзину?" isOpen={noteToTrash !== null} onClose={() => setNoteToTrash(null)}>
                <div className="text-slate-600 dark:text-slate-300">
                  <p>Вы уверены, что хотите переместить эту заметку в корзину?</p>
                  <div className="flex justify-end space-x-4 mt-6">
                    <button 
                      onClick={() => setNoteToTrash(null)}
                      className="px-4 py-2 rounded-md bg-slate-200 hover:bg-slate-300 dark:bg-slate-600 dark:hover:bg-slate-500 text-slate-800 dark:text-white font-semibold transition-colors"
                    >
                      Отмена
                    </button>
                    <button
                      onClick={confirmMoveToTrash}
                      className="px-4 py-2 rounded-md bg-red-600 hover:bg-red-500 text-white font-semibold transition-colors"
                    >
                      Переместить
                    </button>
                  </div>
                </div>
              </Modal>
              
              <Modal title="Удалить навсегда?" isOpen={noteToDelete !== null} onClose={() => setNoteToDelete(null)}>
                <div className="text-slate-600 dark:text-slate-300">
                  <p>Заметка будет удалена навсегда. Это действие нельзя отменить.</p>
                  <div className="flex justify-end space-x-4 mt-6">
                    <button 
                      onClick={() => setNoteToDelete(null)}
                      className="px-4 py-2 rounded-md bg-slate-200 hover:bg-slate-300 dark:bg-slate-600 dark:hover:bg-slate-500 text-slate-800 dark:text-white font-semibold transition-colors"
                    >
                      Отмена
                    </button>
                    <button
                      onClick={confirmDeletePermanently}
                      className="px-4 py-2 rounded-md bg-red-600 hover:bg-red-500 text-white font-semibold transition-colors"
                    >
                      Удалить
                    </button>
                  </div>
                </div>
              </Modal>
              
               <Modal title="Подтвердите действие" isOpen={isDeleteSelectedModalOpen} onClose={() => setDeleteSelectedModalOpen(false)}>
                  <div className="text-slate-600 dark:text-slate-300">
                      <p>Вы уверены, что хотите {view === 'TRASH' ? 'навсегда удалить' : 'переместить в корзину'} {selectedNoteIds.length} {(() => {
                          const count = selectedNoteIds.length;
                          const lastDigit = count % 10;
                          const lastTwoDigits = count % 100;
                          if (lastDigit === 1 && lastTwoDigits !== 11) return 'заметку';
                          if ([2, 3, 4].includes(lastDigit) && ![12, 13, 14].includes(lastTwoDigits)) return 'заметки';
                          return 'заметок';
                      })()}?</p>
                      {view === 'TRASH' && <p className="text-sm text-yellow-500 dark:text-yellow-400 mt-2">Это действие необратимо.</p>}
                      <div className="flex justify-end space-x-4 mt-6">
                      <button 
                          onClick={() => setDeleteSelectedModalOpen(false)}
                          className="px-4 py-2 rounded-md bg-slate-200 hover:bg-slate-300 dark:bg-slate-600 dark:hover:bg-slate-500 text-slate-800 dark:text-white font-semibold transition-colors"
                      >
                          Отмена
                      </button>
                      <button
                          onClick={confirmDeleteSelected}
                          className="px-4 py-2 rounded-md bg-red-600 hover:bg-red-500 text-white font-semibold transition-colors"
                      >
                          {view === 'TRASH' ? 'Удалить' : 'Переместить'}
                      </button>
                      </div>
                  </div>
              </Modal>

              <Modal title="Переместить все в корзину?" isOpen={isDeleteAllModalOpen} onClose={() => setDeleteAllModalOpen(false)}>
                  <div className="text-slate-600 dark:text-slate-300">
                      <p className="mb-2">Вы уверены, что хотите переместить <strong className="text-red-500 dark:text-red-400">все активные</strong> заметки в корзину?</p>
                      <div className="flex justify-end space-x-4 mt-6">
                      <button 
                          onClick={() => setDeleteAllModalOpen(false)}
                          className="px-4 py-2 rounded-md bg-slate-200 hover:bg-slate-300 dark:bg-slate-600 dark:hover:bg-slate-500 text-slate-800 dark:text-white font-semibold transition-colors"
                      >
                          Отмена
                      </button>
                      <button
                          onClick={confirmDeleteAllActive}
                          className="px-4 py-2 rounded-md bg-red-600 hover:bg-red-500 text-white font-semibold transition-colors"
                      >
                          Переместить все
                      </button>
                      </div>
                  </div>
              </Modal>
              
              <Modal title="Очистить корзину?" isOpen={isClearTrashModalOpen} onClose={() => setClearTrashModalOpen(false)}>
                  <div className="text-slate-600 dark:text-slate-300">
                      <p className="mb-2">Вы уверены, что хотите <strong className="text-red-500 dark:text-red-400">навсегда удалить все</strong> заметки из корзины?</p>
                      <p className="text-sm text-yellow-600 dark:text-yellow-400 bg-yellow-100/50 dark:bg-yellow-900/50 p-3 rounded-md">Это действие необратимо. Все данные из корзины будут потеряны.</p>
                      <div className="flex justify-end space-x-4 mt-6">
                      <button 
                          onClick={() => setClearTrashModalOpen(false)}
                          className="px-4 py-2 rounded-md bg-slate-200 hover:bg-slate-300 dark:bg-slate-600 dark:hover:bg-slate-500 text-slate-800 dark:text-white font-semibold transition-colors"
                      >
                          Отмена
                      </button>
                      <button
                          onClick={handleEmptyTrash}
                          className="px-4 py-2 rounded-md bg-red-600 hover:bg-red-500 text-white font-semibold transition-colors"
                      >
                          Очистить корзину
                      </button>
                      </div>
                  </div>
              </Modal>

               <Modal title="Импорт данных" isOpen={isImportModalOpen} onClose={() => setImportModalOpen(false)}>
                  <div className="text-slate-600 dark:text-slate-300">
                      <p className="mb-2">Вы уверены, что хотите импортировать данные?</p>
                      <p className="text-sm text-yellow-600 dark:text-yellow-400 bg-yellow-100/50 dark:bg-yellow-900/50 p-3 rounded-md">Внимание: Текущие заметки и категории будут полностью заменены данными из файла.</p>
                      <div className="flex justify-end space-x-4 mt-6">
                      <button 
                          onClick={() => { setImportModalOpen(false); setDataToImport(null); }}
                          className="px-4 py-2 rounded-md bg-slate-200 hover:bg-slate-300 dark:bg-slate-600 dark:hover:bg-slate-500 text-slate-800 dark:text-white font-semibold transition-colors"
                      >
                          Отмена
                      </button>
                      <button
                          onClick={confirmImportData}
                          className="px-4 py-2 rounded-md bg-cyan-600 hover:bg-cyan-500 text-white font-semibold transition-colors"
                      >
                          Импортировать
                      </button>
                      </div>
                  </div>
              </Modal>

              <Toast toast={activeToast} onDismiss={() => setActiveToast(null)} />
              
              {view === 'LIST' && !isSelectionMode && (
                 <button onClick={() => openEditor(null)} className="fixed bottom-6 right-6 bg-cyan-500 hover:bg-cyan-600 dark:bg-cyan-600 dark:hover:bg-cyan-500 text-white rounded-full p-4 shadow-lg transform transition-transform hover:scale-110" aria-label="Создать заметку">
                   <PlusIcon className="w-8 h-8"/>
                 </button>
              )}

              {isSelectionMode && (
                  <div className="fixed bottom-0 left-0 right-0 bg-white/95 dark:bg-slate-800/95 backdrop-blur-sm border-t border-slate-200 dark:border-slate-700 shadow-lg z-20 animate-fade-in-up">
                      <div className="container mx-auto max-w-3xl p-4 flex justify-between items-center">
                          <button onClick={handleToggleSelectionMode} className="flex items-center space-x-2 px-4 py-2 rounded-md bg-slate-200 dark:bg-slate-600 hover:bg-slate-300 dark:hover:bg-slate-500 text-slate-800 dark:text-white font-semibold transition-colors">
                              <XMarkIcon className="w-5 h-5"/>
                              <span>Отмена</span>
                          </button>
                          <span className="font-semibold text-slate-700 dark:text-slate-300">{selectedNoteIds.length} выбрано</span>
                          <button 
                              onClick={() => setDeleteSelectedModalOpen(true)} 
                              disabled={selectedNoteIds.length === 0} 
                              className="flex items-center space-x-2 px-4 py-2 rounded-md bg-red-600 hover:bg-red-500 text-white font-semibold transition-colors disabled:bg-red-400 dark:disabled:bg-red-800 disabled:cursor-not-allowed"
                          >
                              <TrashIcon className="w-5 h-5"/>
                              <span>{view === 'TRASH' ? 'Удалить' : 'В корзину'}</span>
                          </button>
                      </div>
                  </div>
              )}
            </div>
          </div>
        );
      };
      
      const calculateNextDueDate = (reminder, lastCheckTime) => {
          if (!reminder) return null;

          const sortedTimes = reminder.times
              .map(t => {
                  const [h, m] = t.split(':').map(Number);
                  return { h, m };
              })
              .sort((a, b) => a.h * 60 + a.m - (b.h * 60 + b.m));

          let searchDate = new Date(lastCheckTime);
          searchDate.setHours(0, 0, 0, 0);
          
          const startDate = new Date(reminder.startDate);
          startDate.setHours(0,0,0,0);

          for (let i = 0; i < 730; i++) { 
              if (searchDate.getTime() >= startDate.getTime()) {
                   let isValidDay = false;
                   switch (reminder.type) {
                      case 'daily':
                          isValidDay = true;
                          break;
                      case 'weekly':
                          isValidDay = reminder.daysOfWeek?.includes(searchDate.getDay()) ?? false;
                          break;
                      case 'monthly':
                          isValidDay = searchDate.getDate() === new Date(reminder.startDate).getDate();
                          break;
                      case 'single':
                          isValidDay = searchDate.getTime() === startDate.getTime();
                          break;
                   }

                   if (isValidDay) {
                      for (const time of sortedTimes) {
                          let dueDate = new Date(searchDate);
                          dueDate.setHours(time.h, time.m, 0, 0);

                          if (dueDate.getTime() > lastCheckTime) {
                              if (reminder.endDate && dueDate.getTime() > new Date(reminder.endDate).getTime()) {
                                  return null; 
                              }
                              return dueDate.getTime();
                          }
                      }
                   }
              }
             
              searchDate.setDate(searchDate.getDate() + 1);
          }

          return null;
      };

      const parseMarkdownWithChecklists = (markdown, noteId) => {
          const rawHtml = window.marked.parse(markdown, { gfm: true });
          let checklistItemIndex = -1;
          const processedHtml = rawHtml.replace(/<li class="task-list-item">/g, (match) => {
              checklistItemIndex++;
              return `<li class="task-list-item" data-note-id="${noteId}" data-item-index="${checklistItemIndex}">`;
          }).replace(/<input type="checkbox" disabled="">/g, (match) => {
              return match.replace(' disabled=""', '');
          }).replace(/<li class="task-list-item" data-note-id="(.+?)" data-item-index="(.+?)"><input type="checkbox" checked="">/g, (match) => {
              return match.replace('<li class="task-list-item"', '<li class="task-list-item done"');
          });
          const sanitizedHtml = window.DOMPurify.sanitize(processedHtml, {
              ADD_ATTR: ['data-note-id', 'data-item-index'],
          });
          return { __html: sanitizedHtml };
      };


      // --- End of Bundled Code ---

      const rootElement = document.getElementById('root');
      if (!rootElement) {
        throw new Error("Could not find root element to mount to");
      }
      
      const root = ReactDOM.createRoot(rootElement);
      root.render(
        <React.StrictMode>
          <App />
        </React.StrictMode>
      );
      
      // =================================================================================
      // ВСТАВЬТЕ ВАШУ КОНФИГУРАЦИЮ FIREBASE ЗДЕСЬ
      // Вы найдете ее в Firebase Console: Project settings -> General -> Your apps -> SDK setup and configuration
      // =================================================================================
      const firebaseConfig = {
        apiKey: "AIzaSyDy2phSHb80YLILjK1M06FpwpclHgxvJgz8",
        authDomain: "smart-notepad-1de7f.firebaseapp.com",
        projectId: "smart-notepad-1de7f",
        storageBucket: "smart-notepad-1de7f.appspot.com",
        messagingSenderId: "898845270205",
        appId: "1:898845270205:web:ea28355a98aba55e32d7d4"
      };
      
      // Initialize Firebase
      if (typeof firebase !== 'undefined' && !firebase.apps.length && firebaseConfig.apiKey !== "YOUR_API_KEY_HERE") {
          firebase.initializeApp(firebaseConfig);
      } else {
        console.warn("Firebase config is not set. Push notifications will not work.");
      }
      
      // Register Service Worker for PWA & Firebase
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          // Используем специальный файл для Firebase Messaging
          navigator.serviceWorker.register('service-worker.js')
            .then(registration => {
              console.log('ServiceWorker registration successful with scope: ', registration.scope);
               if (typeof firebase !== 'undefined' && firebase.messaging.isSupported() && firebase.apps.length > 0) {
                  firebase.messaging().useServiceWorker(registration);
              }
            })
            .catch(err => {
              console.log('ServiceWorker registration failed: ', err);
            });
        });
      }
    </script>
  </body>
</html>